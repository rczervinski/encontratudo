"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@iconify";
exports.ids = ["vendor-chunks/@iconify"];
exports.modules = {

/***/ "(ssr)/./node_modules/@iconify/react/dist/iconify.js":
/*!*****************************************************!*\
  !*** ./node_modules/@iconify/react/dist/iconify.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Icon: () => (/* binding */ Icon),\n/* harmony export */   InlineIcon: () => (/* binding */ InlineIcon),\n/* harmony export */   _api: () => (/* binding */ _api),\n/* harmony export */   addAPIProvider: () => (/* binding */ addAPIProvider),\n/* harmony export */   addCollection: () => (/* binding */ addCollection),\n/* harmony export */   addIcon: () => (/* binding */ addIcon),\n/* harmony export */   buildIcon: () => (/* binding */ iconToSVG),\n/* harmony export */   calculateSize: () => (/* binding */ calculateSize),\n/* harmony export */   getIcon: () => (/* binding */ getIcon),\n/* harmony export */   iconLoaded: () => (/* binding */ iconLoaded),\n/* harmony export */   listIcons: () => (/* binding */ listIcons),\n/* harmony export */   loadIcon: () => (/* binding */ loadIcon),\n/* harmony export */   loadIcons: () => (/* binding */ loadIcons),\n/* harmony export */   replaceIDs: () => (/* binding */ replaceIDs),\n/* harmony export */   setCustomIconLoader: () => (/* binding */ setCustomIconLoader),\n/* harmony export */   setCustomIconsLoader: () => (/* binding */ setCustomIconsLoader)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* __next_internal_client_entry_do_not_use__ Icon,InlineIcon,_api,addAPIProvider,addCollection,addIcon,buildIcon,calculateSize,getIcon,iconLoaded,listIcons,loadIcon,loadIcons,replaceIDs,setCustomIconLoader,setCustomIconsLoader auto */ \n/**\n* Resolve icon set icons\n*\n* Returns parent icon for each icon\n*/ function getIconsTree(data, names) {\n    const icons = data.icons;\n    const aliases = data.aliases || Object.create(null);\n    const resolved = Object.create(null);\n    function resolve(name) {\n        if (icons[name]) return resolved[name] = [];\n        if (!(name in resolved)) {\n            resolved[name] = null;\n            const parent = aliases[name] && aliases[name].parent;\n            const value = parent && resolve(parent);\n            if (value) resolved[name] = [\n                parent\n            ].concat(value);\n        }\n        return resolved[name];\n    }\n    Object.keys(icons).concat(Object.keys(aliases)).forEach(resolve);\n    return resolved;\n}\n/**\n* Default values for dimensions\n*/ const defaultIconDimensions = Object.freeze({\n    left: 0,\n    top: 0,\n    width: 16,\n    height: 16\n});\n/**\n* Default values for transformations\n*/ const defaultIconTransformations = Object.freeze({\n    rotate: 0,\n    vFlip: false,\n    hFlip: false\n});\n/**\n* Default values for all optional IconifyIcon properties\n*/ const defaultIconProps = Object.freeze({\n    ...defaultIconDimensions,\n    ...defaultIconTransformations\n});\n/**\n* Default values for all properties used in ExtendedIconifyIcon\n*/ const defaultExtendedIconProps = Object.freeze({\n    ...defaultIconProps,\n    body: \"\",\n    hidden: false\n});\n/**\n* Merge transformations\n*/ function mergeIconTransformations(obj1, obj2) {\n    const result = {};\n    if (!obj1.hFlip !== !obj2.hFlip) result.hFlip = true;\n    if (!obj1.vFlip !== !obj2.vFlip) result.vFlip = true;\n    const rotate = ((obj1.rotate || 0) + (obj2.rotate || 0)) % 4;\n    if (rotate) result.rotate = rotate;\n    return result;\n}\n/**\n* Merge icon and alias\n*\n* Can also be used to merge default values and icon\n*/ function mergeIconData(parent, child) {\n    const result = mergeIconTransformations(parent, child);\n    for(const key in defaultExtendedIconProps)if (key in defaultIconTransformations) {\n        if (key in parent && !(key in result)) result[key] = defaultIconTransformations[key];\n    } else if (key in child) result[key] = child[key];\n    else if (key in parent) result[key] = parent[key];\n    return result;\n}\n/**\n* Get icon data, using prepared aliases tree\n*/ function internalGetIconData(data, name, tree) {\n    const icons = data.icons;\n    const aliases = data.aliases || Object.create(null);\n    let currentProps = {};\n    function parse(name$1) {\n        currentProps = mergeIconData(icons[name$1] || aliases[name$1], currentProps);\n    }\n    parse(name);\n    tree.forEach(parse);\n    return mergeIconData(data, currentProps);\n}\n/**\n* Extract icons from an icon set\n*\n* Returns list of icons that were found in icon set\n*/ function parseIconSet(data, callback) {\n    const names = [];\n    if (typeof data !== \"object\" || typeof data.icons !== \"object\") return names;\n    if (data.not_found instanceof Array) data.not_found.forEach((name)=>{\n        callback(name, null);\n        names.push(name);\n    });\n    const tree = getIconsTree(data);\n    for(const name in tree){\n        const item = tree[name];\n        if (item) {\n            callback(name, internalGetIconData(data, name, item));\n            names.push(name);\n        }\n    }\n    return names;\n}\n/**\n* Optional properties\n*/ const optionalPropertyDefaults = {\n    provider: \"\",\n    aliases: {},\n    not_found: {},\n    ...defaultIconDimensions\n};\n/**\n* Check props\n*/ function checkOptionalProps(item, defaults) {\n    for(const prop in defaults)if (prop in item && typeof item[prop] !== typeof defaults[prop]) return false;\n    return true;\n}\n/**\n* Validate icon set, return it as IconifyJSON on success, null on failure\n*\n* Unlike validateIconSet(), this function is very basic.\n* It does not throw exceptions, it does not check metadata, it does not fix stuff.\n*/ function quicklyValidateIconSet(obj) {\n    if (typeof obj !== \"object\" || obj === null) return null;\n    const data = obj;\n    if (typeof data.prefix !== \"string\" || !obj.icons || typeof obj.icons !== \"object\") return null;\n    if (!checkOptionalProps(obj, optionalPropertyDefaults)) return null;\n    const icons = data.icons;\n    for(const name in icons){\n        const icon = icons[name];\n        if (!name || typeof icon.body !== \"string\" || !checkOptionalProps(icon, defaultExtendedIconProps)) return null;\n    }\n    const aliases = data.aliases || Object.create(null);\n    for(const name in aliases){\n        const icon = aliases[name];\n        const parent = icon.parent;\n        if (!name || typeof parent !== \"string\" || !icons[parent] && !aliases[parent] || !checkOptionalProps(icon, defaultExtendedIconProps)) return null;\n    }\n    return data;\n}\n/**\n* Storage by provider and prefix\n*/ const dataStorage = Object.create(null);\n/**\n* Create new storage\n*/ function newStorage(provider, prefix) {\n    return {\n        provider,\n        prefix,\n        icons: Object.create(null),\n        missing: /* @__PURE__ */ new Set()\n    };\n}\n/**\n* Get storage for provider and prefix\n*/ function getStorage(provider, prefix) {\n    const providerStorage = dataStorage[provider] || (dataStorage[provider] = Object.create(null));\n    return providerStorage[prefix] || (providerStorage[prefix] = newStorage(provider, prefix));\n}\n/**\n* Add icon set to storage\n*\n* Returns array of added icons\n*/ function addIconSet(storage, data) {\n    if (!quicklyValidateIconSet(data)) return [];\n    return parseIconSet(data, (name, icon)=>{\n        if (icon) storage.icons[name] = icon;\n        else storage.missing.add(name);\n    });\n}\n/**\n* Add icon to storage\n*/ function addIconToStorage(storage, name, icon) {\n    try {\n        if (typeof icon.body === \"string\") {\n            storage.icons[name] = {\n                ...icon\n            };\n            return true;\n        }\n    } catch (err) {}\n    return false;\n}\n/**\n* List available icons\n*/ function listIcons(provider, prefix) {\n    let allIcons = [];\n    const providers = typeof provider === \"string\" ? [\n        provider\n    ] : Object.keys(dataStorage);\n    providers.forEach((provider$1)=>{\n        const prefixes = typeof provider$1 === \"string\" && typeof prefix === \"string\" ? [\n            prefix\n        ] : Object.keys(dataStorage[provider$1] || {});\n        prefixes.forEach((prefix$1)=>{\n            const storage = getStorage(provider$1, prefix$1);\n            allIcons = allIcons.concat(Object.keys(storage.icons).map((name)=>(provider$1 !== \"\" ? \"@\" + provider$1 + \":\" : \"\") + prefix$1 + \":\" + name));\n        });\n    });\n    return allIcons;\n}\n/**\n* Expression to test part of icon name.\n*\n* Used when loading icons from Iconify API due to project naming convension.\n* Ignored when using custom icon sets - convension does not apply.\n*/ const matchIconName = /^[a-z0-9]+(-[a-z0-9]+)*$/;\n/**\n* Convert string icon name to IconifyIconName object.\n*/ const stringToIcon = (value, validate, allowSimpleName, provider = \"\")=>{\n    const colonSeparated = value.split(\":\");\n    if (value.slice(0, 1) === \"@\") {\n        if (colonSeparated.length < 2 || colonSeparated.length > 3) return null;\n        provider = colonSeparated.shift().slice(1);\n    }\n    if (colonSeparated.length > 3 || !colonSeparated.length) return null;\n    if (colonSeparated.length > 1) {\n        const name$1 = colonSeparated.pop();\n        const prefix = colonSeparated.pop();\n        const result = {\n            provider: colonSeparated.length > 0 ? colonSeparated[0] : provider,\n            prefix,\n            name: name$1\n        };\n        return validate && !validateIconName(result) ? null : result;\n    }\n    const name = colonSeparated[0];\n    const dashSeparated = name.split(\"-\");\n    if (dashSeparated.length > 1) {\n        const result = {\n            provider,\n            prefix: dashSeparated.shift(),\n            name: dashSeparated.join(\"-\")\n        };\n        return validate && !validateIconName(result) ? null : result;\n    }\n    if (allowSimpleName && provider === \"\") {\n        const result = {\n            provider,\n            prefix: \"\",\n            name\n        };\n        return validate && !validateIconName(result, allowSimpleName) ? null : result;\n    }\n    return null;\n};\n/**\n* Check if icon is valid.\n*\n* This function is not part of stringToIcon because validation is not needed for most code.\n*/ const validateIconName = (icon, allowSimpleName)=>{\n    if (!icon) return false;\n    return !!((allowSimpleName && icon.prefix === \"\" || !!icon.prefix) && !!icon.name);\n};\n/**\n* Allow storing icons without provider or prefix, making it possible to store icons like \"home\"\n*/ let simpleNames = false;\nfunction allowSimpleNames(allow) {\n    if (typeof allow === \"boolean\") simpleNames = allow;\n    return simpleNames;\n}\n/**\n* Get icon data\n*\n* Returns:\n* - IconifyIcon on success, object directly from storage so don't modify it\n* - null if icon is marked as missing (returned in `not_found` property from API, so don't bother sending API requests)\n* - undefined if icon is missing in storage\n*/ function getIconData(name) {\n    const icon = typeof name === \"string\" ? stringToIcon(name, true, simpleNames) : name;\n    if (icon) {\n        const storage = getStorage(icon.provider, icon.prefix);\n        const iconName = icon.name;\n        return storage.icons[iconName] || (storage.missing.has(iconName) ? null : void 0);\n    }\n}\n/**\n* Add one icon\n*/ function addIcon(name, data) {\n    const icon = stringToIcon(name, true, simpleNames);\n    if (!icon) return false;\n    const storage = getStorage(icon.provider, icon.prefix);\n    if (data) return addIconToStorage(storage, icon.name, data);\n    else {\n        storage.missing.add(icon.name);\n        return true;\n    }\n}\n/**\n* Add icon set\n*/ function addCollection(data, provider) {\n    if (typeof data !== \"object\") return false;\n    if (typeof provider !== \"string\") provider = data.provider || \"\";\n    if (simpleNames && !provider && !data.prefix) {\n        let added = false;\n        if (quicklyValidateIconSet(data)) {\n            data.prefix = \"\";\n            parseIconSet(data, (name, icon)=>{\n                if (addIcon(name, icon)) added = true;\n            });\n        }\n        return added;\n    }\n    const prefix = data.prefix;\n    if (!validateIconName({\n        prefix,\n        name: \"a\"\n    })) return false;\n    const storage = getStorage(provider, prefix);\n    return !!addIconSet(storage, data);\n}\n/**\n* Check if icon data is available\n*/ function iconLoaded(name) {\n    return !!getIconData(name);\n}\n/**\n* Get full icon\n*/ function getIcon(name) {\n    const result = getIconData(name);\n    return result ? {\n        ...defaultIconProps,\n        ...result\n    } : result;\n}\n/**\n* Default icon customisations values\n*/ const defaultIconSizeCustomisations = Object.freeze({\n    width: null,\n    height: null\n});\nconst defaultIconCustomisations = Object.freeze({\n    ...defaultIconSizeCustomisations,\n    ...defaultIconTransformations\n});\n/**\n* Regular expressions for calculating dimensions\n*/ const unitsSplit = /(-?[0-9.]*[0-9]+[0-9.]*)/g;\nconst unitsTest = /^-?[0-9.]*[0-9]+[0-9.]*$/g;\nfunction calculateSize(size, ratio, precision) {\n    if (ratio === 1) return size;\n    precision = precision || 100;\n    if (typeof size === \"number\") return Math.ceil(size * ratio * precision) / precision;\n    if (typeof size !== \"string\") return size;\n    const oldParts = size.split(unitsSplit);\n    if (oldParts === null || !oldParts.length) return size;\n    const newParts = [];\n    let code = oldParts.shift();\n    let isNumber = unitsTest.test(code);\n    while(true){\n        if (isNumber) {\n            const num = parseFloat(code);\n            if (isNaN(num)) newParts.push(code);\n            else newParts.push(Math.ceil(num * ratio * precision) / precision);\n        } else newParts.push(code);\n        code = oldParts.shift();\n        if (code === void 0) return newParts.join(\"\");\n        isNumber = !isNumber;\n    }\n}\nfunction splitSVGDefs(content, tag = \"defs\") {\n    let defs = \"\";\n    const index = content.indexOf(\"<\" + tag);\n    while(index >= 0){\n        const start = content.indexOf(\">\", index);\n        const end = content.indexOf(\"</\" + tag);\n        if (start === -1 || end === -1) break;\n        const endEnd = content.indexOf(\">\", end);\n        if (endEnd === -1) break;\n        defs += content.slice(start + 1, end).trim();\n        content = content.slice(0, index).trim() + content.slice(endEnd + 1);\n    }\n    return {\n        defs,\n        content\n    };\n}\n/**\n* Merge defs and content\n*/ function mergeDefsAndContent(defs, content) {\n    return defs ? \"<defs>\" + defs + \"</defs>\" + content : content;\n}\n/**\n* Wrap SVG content, without wrapping definitions\n*/ function wrapSVGContent(body, start, end) {\n    const split = splitSVGDefs(body);\n    return mergeDefsAndContent(split.defs, start + split.content + end);\n}\n/**\n* Check if value should be unset. Allows multiple keywords\n*/ const isUnsetKeyword = (value)=>value === \"unset\" || value === \"undefined\" || value === \"none\";\n/**\n* Get SVG attributes and content from icon + customisations\n*\n* Does not generate style to make it compatible with frameworks that use objects for style, such as React.\n* Instead, it generates 'inline' value. If true, rendering engine should add verticalAlign: -0.125em to icon.\n*\n* Customisations should be normalised by platform specific parser.\n* Result should be converted to <svg> by platform specific parser.\n* Use replaceIDs to generate unique IDs for body.\n*/ function iconToSVG(icon, customisations) {\n    const fullIcon = {\n        ...defaultIconProps,\n        ...icon\n    };\n    const fullCustomisations = {\n        ...defaultIconCustomisations,\n        ...customisations\n    };\n    const box = {\n        left: fullIcon.left,\n        top: fullIcon.top,\n        width: fullIcon.width,\n        height: fullIcon.height\n    };\n    let body = fullIcon.body;\n    [\n        fullIcon,\n        fullCustomisations\n    ].forEach((props)=>{\n        const transformations = [];\n        const hFlip = props.hFlip;\n        const vFlip = props.vFlip;\n        let rotation = props.rotate;\n        if (hFlip) if (vFlip) rotation += 2;\n        else {\n            transformations.push(\"translate(\" + (box.width + box.left).toString() + \" \" + (0 - box.top).toString() + \")\");\n            transformations.push(\"scale(-1 1)\");\n            box.top = box.left = 0;\n        }\n        else if (vFlip) {\n            transformations.push(\"translate(\" + (0 - box.left).toString() + \" \" + (box.height + box.top).toString() + \")\");\n            transformations.push(\"scale(1 -1)\");\n            box.top = box.left = 0;\n        }\n        let tempValue;\n        if (rotation < 0) rotation -= Math.floor(rotation / 4) * 4;\n        rotation = rotation % 4;\n        switch(rotation){\n            case 1:\n                tempValue = box.height / 2 + box.top;\n                transformations.unshift(\"rotate(90 \" + tempValue.toString() + \" \" + tempValue.toString() + \")\");\n                break;\n            case 2:\n                transformations.unshift(\"rotate(180 \" + (box.width / 2 + box.left).toString() + \" \" + (box.height / 2 + box.top).toString() + \")\");\n                break;\n            case 3:\n                tempValue = box.width / 2 + box.left;\n                transformations.unshift(\"rotate(-90 \" + tempValue.toString() + \" \" + tempValue.toString() + \")\");\n                break;\n        }\n        if (rotation % 2 === 1) {\n            if (box.left !== box.top) {\n                tempValue = box.left;\n                box.left = box.top;\n                box.top = tempValue;\n            }\n            if (box.width !== box.height) {\n                tempValue = box.width;\n                box.width = box.height;\n                box.height = tempValue;\n            }\n        }\n        if (transformations.length) body = wrapSVGContent(body, '<g transform=\"' + transformations.join(\" \") + '\">', \"</g>\");\n    });\n    const customisationsWidth = fullCustomisations.width;\n    const customisationsHeight = fullCustomisations.height;\n    const boxWidth = box.width;\n    const boxHeight = box.height;\n    let width;\n    let height;\n    if (customisationsWidth === null) {\n        height = customisationsHeight === null ? \"1em\" : customisationsHeight === \"auto\" ? boxHeight : customisationsHeight;\n        width = calculateSize(height, boxWidth / boxHeight);\n    } else {\n        width = customisationsWidth === \"auto\" ? boxWidth : customisationsWidth;\n        height = customisationsHeight === null ? calculateSize(width, boxHeight / boxWidth) : customisationsHeight === \"auto\" ? boxHeight : customisationsHeight;\n    }\n    const attributes = {};\n    const setAttr = (prop, value)=>{\n        if (!isUnsetKeyword(value)) attributes[prop] = value.toString();\n    };\n    setAttr(\"width\", width);\n    setAttr(\"height\", height);\n    const viewBox = [\n        box.left,\n        box.top,\n        boxWidth,\n        boxHeight\n    ];\n    attributes.viewBox = viewBox.join(\" \");\n    return {\n        attributes,\n        viewBox,\n        body\n    };\n}\n/**\n* IDs usage:\n*\n* id=\"{id}\"\n* xlink:href=\"#{id}\"\n* url(#{id})\n*\n* From SVG animations:\n*\n* begin=\"0;{id}.end\"\n* begin=\"{id}.end\"\n* begin=\"{id}.click\"\n*/ /**\n* Regular expression for finding ids\n*/ const regex = /\\sid=\"(\\S+)\"/g;\n/**\n* New random-ish prefix for ids\n*\n* Do not use dash, it cannot be used in SVG 2 animations\n*/ const randomPrefix = \"IconifyId\" + Date.now().toString(16) + (Math.random() * 16777216 | 0).toString(16);\n/**\n* Counter for ids, increasing with every replacement\n*/ let counter = 0;\n/**\n* Replace IDs in SVG output with unique IDs\n*/ function replaceIDs(body, prefix = randomPrefix) {\n    const ids = [];\n    let match;\n    while(match = regex.exec(body))ids.push(match[1]);\n    if (!ids.length) return body;\n    const suffix = \"suffix\" + (Math.random() * 16777216 | Date.now()).toString(16);\n    ids.forEach((id)=>{\n        const newID = typeof prefix === \"function\" ? prefix(id) : prefix + (counter++).toString();\n        const escapedID = id.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n        body = body.replace(new RegExp('([#;\"])(' + escapedID + ')([\")]|\\\\.[a-z])', \"g\"), \"$1\" + newID + suffix + \"$3\");\n    });\n    body = body.replace(new RegExp(suffix, \"g\"), \"\");\n    return body;\n}\n/**\n* Local storate types and entries\n*/ const storage = Object.create(null);\n/**\n* Set API module\n*/ function setAPIModule(provider, item) {\n    storage[provider] = item;\n}\n/**\n* Get API module\n*/ function getAPIModule(provider) {\n    return storage[provider] || storage[\"\"];\n}\n/**\n* Create full API configuration from partial data\n*/ function createAPIConfig(source) {\n    let resources;\n    if (typeof source.resources === \"string\") resources = [\n        source.resources\n    ];\n    else {\n        resources = source.resources;\n        if (!(resources instanceof Array) || !resources.length) return null;\n    }\n    const result = {\n        resources,\n        path: source.path || \"/\",\n        maxURL: source.maxURL || 500,\n        rotate: source.rotate || 750,\n        timeout: source.timeout || 5e3,\n        random: source.random === true,\n        index: source.index || 0,\n        dataAfterTimeout: source.dataAfterTimeout !== false\n    };\n    return result;\n}\n/**\n* Local storage\n*/ const configStorage = Object.create(null);\n/**\n* Redundancy for API servers.\n*\n* API should have very high uptime because of implemented redundancy at server level, but\n* sometimes bad things happen. On internet 100% uptime is not possible.\n*\n* There could be routing problems. Server might go down for whatever reason, but it takes\n* few minutes to detect that downtime, so during those few minutes API might not be accessible.\n*\n* This script has some redundancy to mitigate possible network issues.\n*\n* If one host cannot be reached in 'rotate' (750 by default) ms, script will try to retrieve\n* data from different host. Hosts have different configurations, pointing to different\n* API servers hosted at different providers.\n*/ const fallBackAPISources = [\n    \"https://api.simplesvg.com\",\n    \"https://api.unisvg.com\"\n];\nconst fallBackAPI = [];\nwhile(fallBackAPISources.length > 0)if (fallBackAPISources.length === 1) fallBackAPI.push(fallBackAPISources.shift());\nelse if (Math.random() > .5) fallBackAPI.push(fallBackAPISources.shift());\nelse fallBackAPI.push(fallBackAPISources.pop());\nconfigStorage[\"\"] = createAPIConfig({\n    resources: [\n        \"https://api.iconify.design\"\n    ].concat(fallBackAPI)\n});\n/**\n* Add custom config for provider\n*/ function addAPIProvider(provider, customConfig) {\n    const config = createAPIConfig(customConfig);\n    if (config === null) return false;\n    configStorage[provider] = config;\n    return true;\n}\n/**\n* Get API configuration\n*/ function getAPIConfig(provider) {\n    return configStorage[provider];\n}\n/**\n* List API providers\n*/ function listAPIProviders() {\n    return Object.keys(configStorage);\n}\nconst detectFetch = ()=>{\n    let callback;\n    try {\n        callback = fetch;\n        if (typeof callback === \"function\") return callback;\n    } catch (err) {}\n};\n/**\n* Fetch function\n*/ let fetchModule = detectFetch();\n/**\n* Set custom fetch() function\n*/ function setFetch(fetch$1) {\n    fetchModule = fetch$1;\n}\n/**\n* Get fetch() function. Used by Icon Finder Core\n*/ function getFetch() {\n    return fetchModule;\n}\n/**\n* Calculate maximum icons list length for prefix\n*/ function calculateMaxLength(provider, prefix) {\n    const config = getAPIConfig(provider);\n    if (!config) return 0;\n    let result;\n    if (!config.maxURL) result = 0;\n    else {\n        let maxHostLength = 0;\n        config.resources.forEach((item)=>{\n            const host = item;\n            maxHostLength = Math.max(maxHostLength, host.length);\n        });\n        const url = prefix + \".json?icons=\";\n        result = config.maxURL - maxHostLength - config.path.length - url.length;\n    }\n    return result;\n}\n/**\n* Should query be aborted, based on last HTTP status\n*/ function shouldAbort(status) {\n    return status === 404;\n}\n/**\n* Prepare params\n*/ const prepare = (provider, prefix, icons)=>{\n    const results = [];\n    const maxLength = calculateMaxLength(provider, prefix);\n    const type = \"icons\";\n    let item = {\n        type,\n        provider,\n        prefix,\n        icons: []\n    };\n    let length = 0;\n    icons.forEach((name, index)=>{\n        length += name.length + 1;\n        if (length >= maxLength && index > 0) {\n            results.push(item);\n            item = {\n                type,\n                provider,\n                prefix,\n                icons: []\n            };\n            length = name.length;\n        }\n        item.icons.push(name);\n    });\n    results.push(item);\n    return results;\n};\n/**\n* Get path\n*/ function getPath(provider) {\n    if (typeof provider === \"string\") {\n        const config = getAPIConfig(provider);\n        if (config) return config.path;\n    }\n    return \"/\";\n}\n/**\n* Load icons\n*/ const send = (host, params, callback)=>{\n    if (!fetchModule) {\n        callback(\"abort\", 424);\n        return;\n    }\n    let path = getPath(params.provider);\n    switch(params.type){\n        case \"icons\":\n            {\n                const prefix = params.prefix;\n                const icons = params.icons;\n                const iconsList = icons.join(\",\");\n                const urlParams = new URLSearchParams({\n                    icons: iconsList\n                });\n                path += prefix + \".json?\" + urlParams.toString();\n                break;\n            }\n        case \"custom\":\n            {\n                const uri = params.uri;\n                path += uri.slice(0, 1) === \"/\" ? uri.slice(1) : uri;\n                break;\n            }\n        default:\n            callback(\"abort\", 400);\n            return;\n    }\n    let defaultError = 503;\n    fetchModule(host + path).then((response)=>{\n        const status = response.status;\n        if (status !== 200) {\n            setTimeout(()=>{\n                callback(shouldAbort(status) ? \"abort\" : \"next\", status);\n            });\n            return;\n        }\n        defaultError = 501;\n        return response.json();\n    }).then((data)=>{\n        if (typeof data !== \"object\" || data === null) {\n            setTimeout(()=>{\n                if (data === 404) callback(\"abort\", data);\n                else callback(\"next\", defaultError);\n            });\n            return;\n        }\n        setTimeout(()=>{\n            callback(\"success\", data);\n        });\n    }).catch(()=>{\n        callback(\"next\", defaultError);\n    });\n};\n/**\n* Export module\n*/ const fetchAPIModule = {\n    prepare,\n    send\n};\n/**\n* Remove callback\n*/ function removeCallback(storages, id) {\n    storages.forEach((storage)=>{\n        const items = storage.loaderCallbacks;\n        if (items) storage.loaderCallbacks = items.filter((row)=>row.id !== id);\n    });\n}\n/**\n* Update all callbacks for provider and prefix\n*/ function updateCallbacks(storage) {\n    if (!storage.pendingCallbacksFlag) {\n        storage.pendingCallbacksFlag = true;\n        setTimeout(()=>{\n            storage.pendingCallbacksFlag = false;\n            const items = storage.loaderCallbacks ? storage.loaderCallbacks.slice(0) : [];\n            if (!items.length) return;\n            let hasPending = false;\n            const provider = storage.provider;\n            const prefix = storage.prefix;\n            items.forEach((item)=>{\n                const icons = item.icons;\n                const oldLength = icons.pending.length;\n                icons.pending = icons.pending.filter((icon)=>{\n                    if (icon.prefix !== prefix) return true;\n                    const name = icon.name;\n                    if (storage.icons[name]) icons.loaded.push({\n                        provider,\n                        prefix,\n                        name\n                    });\n                    else if (storage.missing.has(name)) icons.missing.push({\n                        provider,\n                        prefix,\n                        name\n                    });\n                    else {\n                        hasPending = true;\n                        return true;\n                    }\n                    return false;\n                });\n                if (icons.pending.length !== oldLength) {\n                    if (!hasPending) removeCallback([\n                        storage\n                    ], item.id);\n                    item.callback(icons.loaded.slice(0), icons.missing.slice(0), icons.pending.slice(0), item.abort);\n                }\n            });\n        });\n    }\n}\n/**\n* Unique id counter for callbacks\n*/ let idCounter = 0;\n/**\n* Add callback\n*/ function storeCallback(callback, icons, pendingSources) {\n    const id = idCounter++;\n    const abort = removeCallback.bind(null, pendingSources, id);\n    if (!icons.pending.length) return abort;\n    const item = {\n        id,\n        icons,\n        callback,\n        abort\n    };\n    pendingSources.forEach((storage)=>{\n        (storage.loaderCallbacks || (storage.loaderCallbacks = [])).push(item);\n    });\n    return abort;\n}\n/**\n* Check if icons have been loaded\n*/ function sortIcons(icons) {\n    const result = {\n        loaded: [],\n        missing: [],\n        pending: []\n    };\n    const storage = Object.create(null);\n    icons.sort((a, b)=>{\n        if (a.provider !== b.provider) return a.provider.localeCompare(b.provider);\n        if (a.prefix !== b.prefix) return a.prefix.localeCompare(b.prefix);\n        return a.name.localeCompare(b.name);\n    });\n    let lastIcon = {\n        provider: \"\",\n        prefix: \"\",\n        name: \"\"\n    };\n    icons.forEach((icon)=>{\n        if (lastIcon.name === icon.name && lastIcon.prefix === icon.prefix && lastIcon.provider === icon.provider) return;\n        lastIcon = icon;\n        const provider = icon.provider;\n        const prefix = icon.prefix;\n        const name = icon.name;\n        const providerStorage = storage[provider] || (storage[provider] = Object.create(null));\n        const localStorage = providerStorage[prefix] || (providerStorage[prefix] = getStorage(provider, prefix));\n        let list;\n        if (name in localStorage.icons) list = result.loaded;\n        else if (prefix === \"\" || localStorage.missing.has(name)) list = result.missing;\n        else list = result.pending;\n        const item = {\n            provider,\n            prefix,\n            name\n        };\n        list.push(item);\n    });\n    return result;\n}\n/**\n* Convert icons list from string/icon mix to icons and validate them\n*/ function listToIcons(list, validate = true, simpleNames = false) {\n    const result = [];\n    list.forEach((item)=>{\n        const icon = typeof item === \"string\" ? stringToIcon(item, validate, simpleNames) : item;\n        if (icon) result.push(icon);\n    });\n    return result;\n}\n/**\n* Default RedundancyConfig for API calls\n*/ const defaultConfig = {\n    resources: [],\n    index: 0,\n    timeout: 2e3,\n    rotate: 750,\n    random: false,\n    dataAfterTimeout: false\n};\n/**\n* Send query\n*/ function sendQuery(config, payload, query, done) {\n    const resourcesCount = config.resources.length;\n    const startIndex = config.random ? Math.floor(Math.random() * resourcesCount) : config.index;\n    let resources;\n    if (config.random) {\n        let list = config.resources.slice(0);\n        resources = [];\n        while(list.length > 1){\n            const nextIndex = Math.floor(Math.random() * list.length);\n            resources.push(list[nextIndex]);\n            list = list.slice(0, nextIndex).concat(list.slice(nextIndex + 1));\n        }\n        resources = resources.concat(list);\n    } else resources = config.resources.slice(startIndex).concat(config.resources.slice(0, startIndex));\n    const startTime = Date.now();\n    let status = \"pending\";\n    let queriesSent = 0;\n    let lastError;\n    let timer = null;\n    let queue = [];\n    let doneCallbacks = [];\n    if (typeof done === \"function\") doneCallbacks.push(done);\n    /**\n\t* Reset timer\n\t*/ function resetTimer() {\n        if (timer) {\n            clearTimeout(timer);\n            timer = null;\n        }\n    }\n    /**\n\t* Abort everything\n\t*/ function abort() {\n        if (status === \"pending\") status = \"aborted\";\n        resetTimer();\n        queue.forEach((item)=>{\n            if (item.status === \"pending\") item.status = \"aborted\";\n        });\n        queue = [];\n    }\n    /**\n\t* Add / replace callback to call when execution is complete.\n\t* This can be used to abort pending query implementations when query is complete or aborted.\n\t*/ function subscribe(callback, overwrite) {\n        if (overwrite) doneCallbacks = [];\n        if (typeof callback === \"function\") doneCallbacks.push(callback);\n    }\n    /**\n\t* Get query status\n\t*/ function getQueryStatus() {\n        return {\n            startTime,\n            payload,\n            status,\n            queriesSent,\n            queriesPending: queue.length,\n            subscribe,\n            abort\n        };\n    }\n    /**\n\t* Fail query\n\t*/ function failQuery() {\n        status = \"failed\";\n        doneCallbacks.forEach((callback)=>{\n            callback(void 0, lastError);\n        });\n    }\n    /**\n\t* Clear queue\n\t*/ function clearQueue() {\n        queue.forEach((item)=>{\n            if (item.status === \"pending\") item.status = \"aborted\";\n        });\n        queue = [];\n    }\n    /**\n\t* Got response from module\n\t*/ function moduleResponse(item, response, data) {\n        const isError = response !== \"success\";\n        queue = queue.filter((queued)=>queued !== item);\n        switch(status){\n            case \"pending\":\n                break;\n            case \"failed\":\n                if (isError || !config.dataAfterTimeout) return;\n                break;\n            default:\n                return;\n        }\n        if (response === \"abort\") {\n            lastError = data;\n            failQuery();\n            return;\n        }\n        if (isError) {\n            lastError = data;\n            if (!queue.length) if (!resources.length) failQuery();\n            else execNext();\n            return;\n        }\n        resetTimer();\n        clearQueue();\n        if (!config.random) {\n            const index = config.resources.indexOf(item.resource);\n            if (index !== -1 && index !== config.index) config.index = index;\n        }\n        status = \"completed\";\n        doneCallbacks.forEach((callback)=>{\n            callback(data);\n        });\n    }\n    /**\n\t* Execute next query\n\t*/ function execNext() {\n        if (status !== \"pending\") return;\n        resetTimer();\n        const resource = resources.shift();\n        if (resource === void 0) {\n            if (queue.length) {\n                timer = setTimeout(()=>{\n                    resetTimer();\n                    if (status === \"pending\") {\n                        clearQueue();\n                        failQuery();\n                    }\n                }, config.timeout);\n                return;\n            }\n            failQuery();\n            return;\n        }\n        const item = {\n            status: \"pending\",\n            resource,\n            callback: (status$1, data)=>{\n                moduleResponse(item, status$1, data);\n            }\n        };\n        queue.push(item);\n        queriesSent++;\n        timer = setTimeout(execNext, config.rotate);\n        query(resource, payload, item.callback);\n    }\n    setTimeout(execNext);\n    return getQueryStatus;\n}\n/**\n* Redundancy instance\n*/ function initRedundancy(cfg) {\n    const config = {\n        ...defaultConfig,\n        ...cfg\n    };\n    let queries = [];\n    /**\n\t* Remove aborted and completed queries\n\t*/ function cleanup() {\n        queries = queries.filter((item)=>item().status === \"pending\");\n    }\n    /**\n\t* Send query\n\t*/ function query(payload, queryCallback, doneCallback) {\n        const query$1 = sendQuery(config, payload, queryCallback, (data, error)=>{\n            cleanup();\n            if (doneCallback) doneCallback(data, error);\n        });\n        queries.push(query$1);\n        return query$1;\n    }\n    /**\n\t* Find instance\n\t*/ function find(callback) {\n        return queries.find((value)=>{\n            return callback(value);\n        }) || null;\n    }\n    const instance = {\n        query,\n        find,\n        setIndex: (index)=>{\n            config.index = index;\n        },\n        getIndex: ()=>config.index,\n        cleanup\n    };\n    return instance;\n}\nfunction emptyCallback$1() {}\nconst redundancyCache = Object.create(null);\n/**\n* Get Redundancy instance for provider\n*/ function getRedundancyCache(provider) {\n    if (!redundancyCache[provider]) {\n        const config = getAPIConfig(provider);\n        if (!config) return;\n        const redundancy = initRedundancy(config);\n        const cachedReundancy = {\n            config,\n            redundancy\n        };\n        redundancyCache[provider] = cachedReundancy;\n    }\n    return redundancyCache[provider];\n}\n/**\n* Send API query\n*/ function sendAPIQuery(target, query, callback) {\n    let redundancy;\n    let send;\n    if (typeof target === \"string\") {\n        const api = getAPIModule(target);\n        if (!api) {\n            callback(void 0, 424);\n            return emptyCallback$1;\n        }\n        send = api.send;\n        const cached = getRedundancyCache(target);\n        if (cached) redundancy = cached.redundancy;\n    } else {\n        const config = createAPIConfig(target);\n        if (config) {\n            redundancy = initRedundancy(config);\n            const moduleKey = target.resources ? target.resources[0] : \"\";\n            const api = getAPIModule(moduleKey);\n            if (api) send = api.send;\n        }\n    }\n    if (!redundancy || !send) {\n        callback(void 0, 424);\n        return emptyCallback$1;\n    }\n    return redundancy.query(query, send, callback)().abort;\n}\nfunction emptyCallback() {}\n/**\n* Function called when new icons have been loaded\n*/ function loadedNewIcons(storage) {\n    if (!storage.iconsLoaderFlag) {\n        storage.iconsLoaderFlag = true;\n        setTimeout(()=>{\n            storage.iconsLoaderFlag = false;\n            updateCallbacks(storage);\n        });\n    }\n}\n/**\n* Check icon names for API\n*/ function checkIconNamesForAPI(icons) {\n    const valid = [];\n    const invalid = [];\n    icons.forEach((name)=>{\n        (name.match(matchIconName) ? valid : invalid).push(name);\n    });\n    return {\n        valid,\n        invalid\n    };\n}\n/**\n* Parse loader response\n*/ function parseLoaderResponse(storage, icons, data) {\n    function checkMissing() {\n        const pending = storage.pendingIcons;\n        icons.forEach((name)=>{\n            if (pending) pending.delete(name);\n            if (!storage.icons[name]) storage.missing.add(name);\n        });\n    }\n    if (data && typeof data === \"object\") try {\n        const parsed = addIconSet(storage, data);\n        if (!parsed.length) {\n            checkMissing();\n            return;\n        }\n    } catch (err) {\n        console.error(err);\n    }\n    checkMissing();\n    loadedNewIcons(storage);\n}\n/**\n* Handle response that can be async\n*/ function parsePossiblyAsyncResponse(response, callback) {\n    if (response instanceof Promise) response.then((data)=>{\n        callback(data);\n    }).catch(()=>{\n        callback(null);\n    });\n    else callback(response);\n}\n/**\n* Load icons\n*/ function loadNewIcons(storage, icons) {\n    if (!storage.iconsToLoad) storage.iconsToLoad = icons;\n    else storage.iconsToLoad = storage.iconsToLoad.concat(icons).sort();\n    if (!storage.iconsQueueFlag) {\n        storage.iconsQueueFlag = true;\n        setTimeout(()=>{\n            storage.iconsQueueFlag = false;\n            const { provider, prefix } = storage;\n            const icons$1 = storage.iconsToLoad;\n            delete storage.iconsToLoad;\n            if (!icons$1 || !icons$1.length) return;\n            const customIconLoader = storage.loadIcon;\n            if (storage.loadIcons && (icons$1.length > 1 || !customIconLoader)) {\n                parsePossiblyAsyncResponse(storage.loadIcons(icons$1, prefix, provider), (data)=>{\n                    parseLoaderResponse(storage, icons$1, data);\n                });\n                return;\n            }\n            if (customIconLoader) {\n                icons$1.forEach((name)=>{\n                    const response = customIconLoader(name, prefix, provider);\n                    parsePossiblyAsyncResponse(response, (data)=>{\n                        const iconSet = data ? {\n                            prefix,\n                            icons: {\n                                [name]: data\n                            }\n                        } : null;\n                        parseLoaderResponse(storage, [\n                            name\n                        ], iconSet);\n                    });\n                });\n                return;\n            }\n            const { valid, invalid } = checkIconNamesForAPI(icons$1);\n            if (invalid.length) parseLoaderResponse(storage, invalid, null);\n            if (!valid.length) return;\n            const api = prefix.match(matchIconName) ? getAPIModule(provider) : null;\n            if (!api) {\n                parseLoaderResponse(storage, valid, null);\n                return;\n            }\n            const params = api.prepare(provider, prefix, valid);\n            params.forEach((item)=>{\n                sendAPIQuery(provider, item, (data)=>{\n                    parseLoaderResponse(storage, item.icons, data);\n                });\n            });\n        });\n    }\n}\n/**\n* Load icons\n*/ const loadIcons = (icons, callback)=>{\n    const cleanedIcons = listToIcons(icons, true, allowSimpleNames());\n    const sortedIcons = sortIcons(cleanedIcons);\n    if (!sortedIcons.pending.length) {\n        let callCallback = true;\n        if (callback) setTimeout(()=>{\n            if (callCallback) callback(sortedIcons.loaded, sortedIcons.missing, sortedIcons.pending, emptyCallback);\n        });\n        return ()=>{\n            callCallback = false;\n        };\n    }\n    const newIcons = Object.create(null);\n    const sources = [];\n    let lastProvider, lastPrefix;\n    sortedIcons.pending.forEach((icon)=>{\n        const { provider, prefix } = icon;\n        if (prefix === lastPrefix && provider === lastProvider) return;\n        lastProvider = provider;\n        lastPrefix = prefix;\n        sources.push(getStorage(provider, prefix));\n        const providerNewIcons = newIcons[provider] || (newIcons[provider] = Object.create(null));\n        if (!providerNewIcons[prefix]) providerNewIcons[prefix] = [];\n    });\n    sortedIcons.pending.forEach((icon)=>{\n        const { provider, prefix, name } = icon;\n        const storage = getStorage(provider, prefix);\n        const pendingQueue = storage.pendingIcons || (storage.pendingIcons = /* @__PURE__ */ new Set());\n        if (!pendingQueue.has(name)) {\n            pendingQueue.add(name);\n            newIcons[provider][prefix].push(name);\n        }\n    });\n    sources.forEach((storage)=>{\n        const list = newIcons[storage.provider][storage.prefix];\n        if (list.length) loadNewIcons(storage, list);\n    });\n    return callback ? storeCallback(callback, sortedIcons, sources) : emptyCallback;\n};\n/**\n* Load one icon using Promise\n*/ const loadIcon = (icon)=>{\n    return new Promise((fulfill, reject)=>{\n        const iconObj = typeof icon === \"string\" ? stringToIcon(icon, true) : icon;\n        if (!iconObj) {\n            reject(icon);\n            return;\n        }\n        loadIcons([\n            iconObj || icon\n        ], (loaded)=>{\n            if (loaded.length && iconObj) {\n                const data = getIconData(iconObj);\n                if (data) {\n                    fulfill({\n                        ...defaultIconProps,\n                        ...data\n                    });\n                    return;\n                }\n            }\n            reject(icon);\n        });\n    });\n};\n/**\n* Set custom loader for multiple icons\n*/ function setCustomIconsLoader(loader, prefix, provider) {\n    getStorage(provider || \"\", prefix).loadIcons = loader;\n}\n/**\n* Set custom loader for one icon\n*/ function setCustomIconLoader(loader, prefix, provider) {\n    getStorage(provider || \"\", prefix).loadIcon = loader;\n}\n/**\n* Convert IconifyIconCustomisations to FullIconCustomisations, checking value types\n*/ function mergeCustomisations(defaults, item) {\n    const result = {\n        ...defaults\n    };\n    for(const key in item){\n        const value = item[key];\n        const valueType = typeof value;\n        if (key in defaultIconSizeCustomisations) {\n            if (value === null || value && (valueType === \"string\" || valueType === \"number\")) result[key] = value;\n        } else if (valueType === typeof result[key]) result[key] = key === \"rotate\" ? value % 4 : value;\n    }\n    return result;\n}\nconst separator = /[\\s,]+/;\n/**\n* Apply \"flip\" string to icon customisations\n*/ function flipFromString(custom, flip) {\n    flip.split(separator).forEach((str)=>{\n        const value = str.trim();\n        switch(value){\n            case \"horizontal\":\n                custom.hFlip = true;\n                break;\n            case \"vertical\":\n                custom.vFlip = true;\n                break;\n        }\n    });\n}\n/**\n* Get rotation value\n*/ function rotateFromString(value, defaultValue = 0) {\n    const units = value.replace(/^-?[0-9.]*/, \"\");\n    function cleanup(value$1) {\n        while(value$1 < 0)value$1 += 4;\n        return value$1 % 4;\n    }\n    if (units === \"\") {\n        const num = parseInt(value);\n        return isNaN(num) ? 0 : cleanup(num);\n    } else if (units !== value) {\n        let split = 0;\n        switch(units){\n            case \"%\":\n                split = 25;\n                break;\n            case \"deg\":\n                split = 90;\n        }\n        if (split) {\n            let num = parseFloat(value.slice(0, value.length - units.length));\n            if (isNaN(num)) return 0;\n            num = num / split;\n            return num % 1 === 0 ? cleanup(num) : 0;\n        }\n    }\n    return defaultValue;\n}\n/**\n* Generate <svg>\n*/ function iconToHTML(body, attributes) {\n    let renderAttribsHTML = body.indexOf(\"xlink:\") === -1 ? \"\" : ' xmlns:xlink=\"http://www.w3.org/1999/xlink\"';\n    for(const attr in attributes)renderAttribsHTML += \" \" + attr + '=\"' + attributes[attr] + '\"';\n    return '<svg xmlns=\"http://www.w3.org/2000/svg\"' + renderAttribsHTML + \">\" + body + \"</svg>\";\n}\n/**\n* Encode SVG for use in url()\n*\n* Short alternative to encodeURIComponent() that encodes only stuff used in SVG, generating\n* smaller code.\n*/ function encodeSVGforURL(svg) {\n    return svg.replace(/\"/g, \"'\").replace(/%/g, \"%25\").replace(/#/g, \"%23\").replace(/</g, \"%3C\").replace(/>/g, \"%3E\").replace(/\\s+/g, \" \");\n}\n/**\n* Generate data: URL from SVG\n*/ function svgToData(svg) {\n    return \"data:image/svg+xml,\" + encodeSVGforURL(svg);\n}\n/**\n* Generate url() from SVG\n*/ function svgToURL(svg) {\n    return 'url(\"' + svgToData(svg) + '\")';\n}\nlet policy;\n/**\n* Attempt to create policy\n*/ function createPolicy() {\n    try {\n        policy = window.trustedTypes.createPolicy(\"iconify\", {\n            createHTML: (s)=>s\n        });\n    } catch (err) {\n        policy = null;\n    }\n}\n/**\n* Clean up value for innerHTML assignment\n*\n* This code doesn't actually clean up anything.\n* It is intended be used with Iconify icon data, which has already been validated\n*/ function cleanUpInnerHTML(html) {\n    if (policy === void 0) createPolicy();\n    return policy ? policy.createHTML(html) : html;\n}\nconst defaultExtendedIconCustomisations = {\n    ...defaultIconCustomisations,\n    inline: false\n};\n/**\n * Default SVG attributes\n */ const svgDefaults = {\n    \"xmlns\": \"http://www.w3.org/2000/svg\",\n    \"xmlnsXlink\": \"http://www.w3.org/1999/xlink\",\n    \"aria-hidden\": true,\n    \"role\": \"img\"\n};\n/**\n * Style modes\n */ const commonProps = {\n    display: \"inline-block\"\n};\nconst monotoneProps = {\n    backgroundColor: \"currentColor\"\n};\nconst coloredProps = {\n    backgroundColor: \"transparent\"\n};\n// Dynamically add common props to variables above\nconst propsToAdd = {\n    Image: \"var(--svg)\",\n    Repeat: \"no-repeat\",\n    Size: \"100% 100%\"\n};\nconst propsToAddTo = {\n    WebkitMask: monotoneProps,\n    mask: monotoneProps,\n    background: coloredProps\n};\nfor(const prefix in propsToAddTo){\n    const list = propsToAddTo[prefix];\n    for(const prop in propsToAdd){\n        list[prefix + prop] = propsToAdd[prop];\n    }\n}\n/**\n * Default values for customisations for inline icon\n */ const inlineDefaults = {\n    ...defaultExtendedIconCustomisations,\n    inline: true\n};\n/**\n * Fix size: add 'px' to numbers\n */ function fixSize(value) {\n    return value + (value.match(/^[-0-9.]+$/) ? \"px\" : \"\");\n}\n/**\n * Render icon\n */ const render = (// Icon must be validated before calling this function\nicon, // Partial properties\nprops, // Icon name\nname)=>{\n    // Get default properties\n    const defaultProps = props.inline ? inlineDefaults : defaultExtendedIconCustomisations;\n    // Get all customisations\n    const customisations = mergeCustomisations(defaultProps, props);\n    // Check mode\n    const mode = props.mode || \"svg\";\n    // Create style\n    const style = {};\n    const customStyle = props.style || {};\n    // Create SVG component properties\n    const componentProps = {\n        ...mode === \"svg\" ? svgDefaults : {}\n    };\n    if (name) {\n        const iconName = stringToIcon(name, false, true);\n        if (iconName) {\n            const classNames = [\n                \"iconify\"\n            ];\n            const props = [\n                \"provider\",\n                \"prefix\"\n            ];\n            for (const prop of props){\n                if (iconName[prop]) {\n                    classNames.push(\"iconify--\" + iconName[prop]);\n                }\n            }\n            componentProps.className = classNames.join(\" \");\n        }\n    }\n    // Get element properties\n    for(let key in props){\n        const value = props[key];\n        if (value === void 0) {\n            continue;\n        }\n        switch(key){\n            // Properties to ignore\n            case \"icon\":\n            case \"style\":\n            case \"children\":\n            case \"onLoad\":\n            case \"mode\":\n            case \"ssr\":\n            case \"fallback\":\n                break;\n            // Forward ref\n            case \"_ref\":\n                componentProps.ref = value;\n                break;\n            // Merge class names\n            case \"className\":\n                componentProps[key] = (componentProps[key] ? componentProps[key] + \" \" : \"\") + value;\n                break;\n            // Boolean attributes\n            case \"inline\":\n            case \"hFlip\":\n            case \"vFlip\":\n                customisations[key] = value === true || value === \"true\" || value === 1;\n                break;\n            // Flip as string: 'horizontal,vertical'\n            case \"flip\":\n                if (typeof value === \"string\") {\n                    flipFromString(customisations, value);\n                }\n                break;\n            // Color: copy to style\n            case \"color\":\n                style.color = value;\n                break;\n            // Rotation as string\n            case \"rotate\":\n                if (typeof value === \"string\") {\n                    customisations[key] = rotateFromString(value);\n                } else if (typeof value === \"number\") {\n                    customisations[key] = value;\n                }\n                break;\n            // Remove aria-hidden\n            case \"ariaHidden\":\n            case \"aria-hidden\":\n                if (value !== true && value !== \"true\") {\n                    delete componentProps[\"aria-hidden\"];\n                }\n                break;\n            // Copy missing property if it does not exist in customisations\n            default:\n                if (defaultProps[key] === void 0) {\n                    componentProps[key] = value;\n                }\n        }\n    }\n    // Generate icon\n    const item = iconToSVG(icon, customisations);\n    const renderAttribs = item.attributes;\n    // Inline display\n    if (customisations.inline) {\n        style.verticalAlign = \"-0.125em\";\n    }\n    if (mode === \"svg\") {\n        // Add style\n        componentProps.style = {\n            ...style,\n            ...customStyle\n        };\n        // Add icon stuff\n        Object.assign(componentProps, renderAttribs);\n        // Counter for ids based on \"id\" property to render icons consistently on server and client\n        let localCounter = 0;\n        let id = props.id;\n        if (typeof id === \"string\") {\n            // Convert '-' to '_' to avoid errors in animations\n            id = id.replace(/-/g, \"_\");\n        }\n        // Add icon stuff\n        componentProps.dangerouslySetInnerHTML = {\n            __html: cleanUpInnerHTML(replaceIDs(item.body, id ? ()=>id + \"ID\" + localCounter++ : \"iconifyReact\"))\n        };\n        return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"svg\", componentProps);\n    }\n    // Render <span> with style\n    const { body, width, height } = icon;\n    const useMask = mode === \"mask\" || (mode === \"bg\" ? false : body.indexOf(\"currentColor\") !== -1);\n    // Generate SVG\n    const html = iconToHTML(body, {\n        ...renderAttribs,\n        width: width + \"\",\n        height: height + \"\"\n    });\n    // Generate style\n    componentProps.style = {\n        ...style,\n        \"--svg\": svgToURL(html),\n        \"width\": fixSize(renderAttribs.width),\n        \"height\": fixSize(renderAttribs.height),\n        ...commonProps,\n        ...useMask ? monotoneProps : coloredProps,\n        ...customStyle\n    };\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"span\", componentProps);\n};\n/**\n * Initialise stuff\n */ // Enable short names\nallowSimpleNames(true);\n// Set API module\nsetAPIModule(\"\", fetchAPIModule);\n/**\n * Browser stuff\n */ if (typeof document !== \"undefined\" && \"undefined\" !== \"undefined\") {}\nfunction IconComponent(props) {\n    const [mounted, setMounted] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(!!props.ssr);\n    const [abort, setAbort] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({});\n    // Get initial state\n    function getInitialState(mounted) {\n        if (mounted) {\n            const name = props.icon;\n            if (typeof name === \"object\") {\n                // Icon as object\n                return {\n                    name: \"\",\n                    data: name\n                };\n            }\n            const data = getIconData(name);\n            if (data) {\n                return {\n                    name,\n                    data\n                };\n            }\n        }\n        return {\n            name: \"\"\n        };\n    }\n    const [state, setState] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(getInitialState(!!props.ssr));\n    // Cancel loading\n    function cleanup() {\n        const callback = abort.callback;\n        if (callback) {\n            callback();\n            setAbort({});\n        }\n    }\n    // Change state if it is different\n    function changeState(newState) {\n        if (JSON.stringify(state) !== JSON.stringify(newState)) {\n            cleanup();\n            setState(newState);\n            return true;\n        }\n    }\n    // Update state\n    function updateState() {\n        var _a;\n        const name = props.icon;\n        if (typeof name === \"object\") {\n            // Icon as object\n            changeState({\n                name: \"\",\n                data: name\n            });\n            return;\n        }\n        // New icon or got icon data\n        const data = getIconData(name);\n        if (changeState({\n            name,\n            data\n        })) {\n            if (data === undefined) {\n                // Load icon, update state when done\n                const callback = loadIcons([\n                    name\n                ], updateState);\n                setAbort({\n                    callback\n                });\n            } else if (data) {\n                // Icon data is available: trigger onLoad callback if present\n                (_a = props.onLoad) === null || _a === void 0 ? void 0 : _a.call(props, name);\n            }\n        }\n    }\n    // Mounted state, cleanup for loader\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        setMounted(true);\n        return cleanup;\n    }, []);\n    // Icon changed or component mounted\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (mounted) {\n            updateState();\n        }\n    }, [\n        props.icon,\n        mounted\n    ]);\n    // Render icon\n    const { name, data } = state;\n    if (!data) {\n        return props.children ? props.children : props.fallback ? props.fallback : /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"span\", {});\n    }\n    return render({\n        ...defaultIconProps,\n        ...data\n    }, props, name);\n}\n/**\n * Block icon\n *\n * @param props - Component properties\n */ const Icon = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)((props, ref)=>IconComponent({\n        ...props,\n        _ref: ref\n    }));\n/**\n * Inline icon (has negative verticalAlign that makes it behave like icon font)\n *\n * @param props - Component properties\n */ const InlineIcon = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)((props, ref)=>IconComponent({\n        inline: true,\n        ...props,\n        _ref: ref\n    }));\n/**\n * Internal API\n */ const _api = {\n    getAPIConfig,\n    setAPIModule,\n    sendAPIQuery,\n    setFetch,\n    getFetch,\n    listAPIProviders\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGljb25pZnkvcmVhY3QvZGlzdC9pY29uaWZ5LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzJPQUV1RTtBQUV2RTs7OztBQUlBLEdBQ0EsU0FBU0ksYUFBYUMsSUFBSSxFQUFFQyxLQUFLO0lBQ2hDLE1BQU1DLFFBQVFGLEtBQUtFLEtBQUs7SUFDeEIsTUFBTUMsVUFBVUgsS0FBS0csT0FBTyxJQUFJQyxPQUFPQyxNQUFNLENBQUM7SUFDOUMsTUFBTUMsV0FBV0YsT0FBT0MsTUFBTSxDQUFDO0lBQy9CLFNBQVNFLFFBQVFDLElBQUk7UUFDcEIsSUFBSU4sS0FBSyxDQUFDTSxLQUFLLEVBQUUsT0FBT0YsUUFBUSxDQUFDRSxLQUFLLEdBQUcsRUFBRTtRQUMzQyxJQUFJLENBQUVBLENBQUFBLFFBQVFGLFFBQU8sR0FBSTtZQUN4QkEsUUFBUSxDQUFDRSxLQUFLLEdBQUc7WUFDakIsTUFBTUMsU0FBU04sT0FBTyxDQUFDSyxLQUFLLElBQUlMLE9BQU8sQ0FBQ0ssS0FBSyxDQUFDQyxNQUFNO1lBQ3BELE1BQU1DLFFBQVFELFVBQVVGLFFBQVFFO1lBQ2hDLElBQUlDLE9BQU9KLFFBQVEsQ0FBQ0UsS0FBSyxHQUFHO2dCQUFDQzthQUFPLENBQUNFLE1BQU0sQ0FBQ0Q7UUFDN0M7UUFDQSxPQUFPSixRQUFRLENBQUNFLEtBQUs7SUFDdEI7SUFDQ0osT0FBT1EsSUFBSSxDQUFDVixPQUFPUyxNQUFNLENBQUNQLE9BQU9RLElBQUksQ0FBQ1QsVUFBV1UsT0FBTyxDQUFDTjtJQUMxRCxPQUFPRDtBQUNSO0FBRUE7O0FBRUEsR0FDQSxNQUFNUSx3QkFBd0JWLE9BQU9XLE1BQU0sQ0FBQztJQUMzQ0MsTUFBTTtJQUNOQyxLQUFLO0lBQ0xDLE9BQU87SUFDUEMsUUFBUTtBQUNUO0FBQ0E7O0FBRUEsR0FDQSxNQUFNQyw2QkFBNkJoQixPQUFPVyxNQUFNLENBQUM7SUFDaERNLFFBQVE7SUFDUkMsT0FBTztJQUNQQyxPQUFP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LGlEQUFVQSxDQUFDLENBQUN5SSxPQUFPb1AsTUFBUWUsY0FBYztRQUN4RHhDLFFBQVE7UUFDUixHQUFHM04sS0FBSztRQUNSdVIsTUFBTW5DO0lBQ1Y7QUFDQTs7Q0FFQyxHQUNELE1BQU1xQyxPQUFPO0lBQ1Q1TztJQUNBZjtJQUNBdUg7SUFDQW5HO0lBQ0FFO0lBQ0FOO0FBQ0o7QUFFNk4iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lbmNvbnRyYXR1ZG8td2ViLy4vbm9kZV9tb2R1bGVzL0BpY29uaWZ5L3JlYWN0L2Rpc3QvaWNvbmlmeS5qcz8xMDliIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50JztcblxuaW1wb3J0IHsgY3JlYXRlRWxlbWVudCwgZm9yd2FyZFJlZiwgdXNlU3RhdGUsIHVzZUVmZmVjdCB9IGZyb20gJ3JlYWN0JztcblxuLyoqXG4qIFJlc29sdmUgaWNvbiBzZXQgaWNvbnNcbipcbiogUmV0dXJucyBwYXJlbnQgaWNvbiBmb3IgZWFjaCBpY29uXG4qL1xuZnVuY3Rpb24gZ2V0SWNvbnNUcmVlKGRhdGEsIG5hbWVzKSB7XG5cdGNvbnN0IGljb25zID0gZGF0YS5pY29ucztcblx0Y29uc3QgYWxpYXNlcyA9IGRhdGEuYWxpYXNlcyB8fCBPYmplY3QuY3JlYXRlKG51bGwpO1xuXHRjb25zdCByZXNvbHZlZCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cdGZ1bmN0aW9uIHJlc29sdmUobmFtZSkge1xuXHRcdGlmIChpY29uc1tuYW1lXSkgcmV0dXJuIHJlc29sdmVkW25hbWVdID0gW107XG5cdFx0aWYgKCEobmFtZSBpbiByZXNvbHZlZCkpIHtcblx0XHRcdHJlc29sdmVkW25hbWVdID0gbnVsbDtcblx0XHRcdGNvbnN0IHBhcmVudCA9IGFsaWFzZXNbbmFtZV0gJiYgYWxpYXNlc1tuYW1lXS5wYXJlbnQ7XG5cdFx0XHRjb25zdCB2YWx1ZSA9IHBhcmVudCAmJiByZXNvbHZlKHBhcmVudCk7XG5cdFx0XHRpZiAodmFsdWUpIHJlc29sdmVkW25hbWVdID0gW3BhcmVudF0uY29uY2F0KHZhbHVlKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlc29sdmVkW25hbWVdO1xuXHR9XG5cdChPYmplY3Qua2V5cyhpY29ucykuY29uY2F0KE9iamVjdC5rZXlzKGFsaWFzZXMpKSkuZm9yRWFjaChyZXNvbHZlKTtcblx0cmV0dXJuIHJlc29sdmVkO1xufVxuXG4vKipcbiogRGVmYXVsdCB2YWx1ZXMgZm9yIGRpbWVuc2lvbnNcbiovXG5jb25zdCBkZWZhdWx0SWNvbkRpbWVuc2lvbnMgPSBPYmplY3QuZnJlZXplKHtcblx0bGVmdDogMCxcblx0dG9wOiAwLFxuXHR3aWR0aDogMTYsXG5cdGhlaWdodDogMTZcbn0pO1xuLyoqXG4qIERlZmF1bHQgdmFsdWVzIGZvciB0cmFuc2Zvcm1hdGlvbnNcbiovXG5jb25zdCBkZWZhdWx0SWNvblRyYW5zZm9ybWF0aW9ucyA9IE9iamVjdC5mcmVlemUoe1xuXHRyb3RhdGU6IDAsXG5cdHZGbGlwOiBmYWxzZSxcblx0aEZsaXA6IGZhbHNlXG59KTtcbi8qKlxuKiBEZWZhdWx0IHZhbHVlcyBmb3IgYWxsIG9wdGlvbmFsIEljb25pZnlJY29uIHByb3BlcnRpZXNcbiovXG5jb25zdCBkZWZhdWx0SWNvblByb3BzID0gT2JqZWN0LmZyZWV6ZSh7XG5cdC4uLmRlZmF1bHRJY29uRGltZW5zaW9ucyxcblx0Li4uZGVmYXVsdEljb25UcmFuc2Zvcm1hdGlvbnNcbn0pO1xuLyoqXG4qIERlZmF1bHQgdmFsdWVzIGZvciBhbGwgcHJvcGVydGllcyB1c2VkIGluIEV4dGVuZGVkSWNvbmlmeUljb25cbiovXG5jb25zdCBkZWZhdWx0RXh0ZW5kZWRJY29uUHJvcHMgPSBPYmplY3QuZnJlZXplKHtcblx0Li4uZGVmYXVsdEljb25Qcm9wcyxcblx0Ym9keTogXCJcIixcblx0aGlkZGVuOiBmYWxzZVxufSk7XG5cbi8qKlxuKiBNZXJnZSB0cmFuc2Zvcm1hdGlvbnNcbiovXG5mdW5jdGlvbiBtZXJnZUljb25UcmFuc2Zvcm1hdGlvbnMob2JqMSwgb2JqMikge1xuXHRjb25zdCByZXN1bHQgPSB7fTtcblx0aWYgKCFvYmoxLmhGbGlwICE9PSAhb2JqMi5oRmxpcCkgcmVzdWx0LmhGbGlwID0gdHJ1ZTtcblx0aWYgKCFvYmoxLnZGbGlwICE9PSAhb2JqMi52RmxpcCkgcmVzdWx0LnZGbGlwID0gdHJ1ZTtcblx0Y29uc3Qgcm90YXRlID0gKChvYmoxLnJvdGF0ZSB8fCAwKSArIChvYmoyLnJvdGF0ZSB8fCAwKSkgJSA0O1xuXHRpZiAocm90YXRlKSByZXN1bHQucm90YXRlID0gcm90YXRlO1xuXHRyZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiogTWVyZ2UgaWNvbiBhbmQgYWxpYXNcbipcbiogQ2FuIGFsc28gYmUgdXNlZCB0byBtZXJnZSBkZWZhdWx0IHZhbHVlcyBhbmQgaWNvblxuKi9cbmZ1bmN0aW9uIG1lcmdlSWNvbkRhdGEocGFyZW50LCBjaGlsZCkge1xuXHRjb25zdCByZXN1bHQgPSBtZXJnZUljb25UcmFuc2Zvcm1hdGlvbnMocGFyZW50LCBjaGlsZCk7XG5cdGZvciAoY29uc3Qga2V5IGluIGRlZmF1bHRFeHRlbmRlZEljb25Qcm9wcykgaWYgKGtleSBpbiBkZWZhdWx0SWNvblRyYW5zZm9ybWF0aW9ucykge1xuXHRcdGlmIChrZXkgaW4gcGFyZW50ICYmICEoa2V5IGluIHJlc3VsdCkpIHJlc3VsdFtrZXldID0gZGVmYXVsdEljb25UcmFuc2Zvcm1hdGlvbnNba2V5XTtcblx0fSBlbHNlIGlmIChrZXkgaW4gY2hpbGQpIHJlc3VsdFtrZXldID0gY2hpbGRba2V5XTtcblx0ZWxzZSBpZiAoa2V5IGluIHBhcmVudCkgcmVzdWx0W2tleV0gPSBwYXJlbnRba2V5XTtcblx0cmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4qIEdldCBpY29uIGRhdGEsIHVzaW5nIHByZXBhcmVkIGFsaWFzZXMgdHJlZVxuKi9cbmZ1bmN0aW9uIGludGVybmFsR2V0SWNvbkRhdGEoZGF0YSwgbmFtZSwgdHJlZSkge1xuXHRjb25zdCBpY29ucyA9IGRhdGEuaWNvbnM7XG5cdGNvbnN0IGFsaWFzZXMgPSBkYXRhLmFsaWFzZXMgfHwgT2JqZWN0LmNyZWF0ZShudWxsKTtcblx0bGV0IGN1cnJlbnRQcm9wcyA9IHt9O1xuXHRmdW5jdGlvbiBwYXJzZShuYW1lJDEpIHtcblx0XHRjdXJyZW50UHJvcHMgPSBtZXJnZUljb25EYXRhKGljb25zW25hbWUkMV0gfHwgYWxpYXNlc1tuYW1lJDFdLCBjdXJyZW50UHJvcHMpO1xuXHR9XG5cdHBhcnNlKG5hbWUpO1xuXHR0cmVlLmZvckVhY2gocGFyc2UpO1xuXHRyZXR1cm4gbWVyZ2VJY29uRGF0YShkYXRhLCBjdXJyZW50UHJvcHMpO1xufVxuXG4vKipcbiogRXh0cmFjdCBpY29ucyBmcm9tIGFuIGljb24gc2V0XG4qXG4qIFJldHVybnMgbGlzdCBvZiBpY29ucyB0aGF0IHdlcmUgZm91bmQgaW4gaWNvbiBzZXRcbiovXG5mdW5jdGlvbiBwYXJzZUljb25TZXQoZGF0YSwgY2FsbGJhY2spIHtcblx0Y29uc3QgbmFtZXMgPSBbXTtcblx0aWYgKHR5cGVvZiBkYXRhICE9PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBkYXRhLmljb25zICE9PSBcIm9iamVjdFwiKSByZXR1cm4gbmFtZXM7XG5cdGlmIChkYXRhLm5vdF9mb3VuZCBpbnN0YW5jZW9mIEFycmF5KSBkYXRhLm5vdF9mb3VuZC5mb3JFYWNoKChuYW1lKSA9PiB7XG5cdFx0Y2FsbGJhY2sobmFtZSwgbnVsbCk7XG5cdFx0bmFtZXMucHVzaChuYW1lKTtcblx0fSk7XG5cdGNvbnN0IHRyZWUgPSBnZXRJY29uc1RyZWUoZGF0YSk7XG5cdGZvciAoY29uc3QgbmFtZSBpbiB0cmVlKSB7XG5cdFx0Y29uc3QgaXRlbSA9IHRyZWVbbmFtZV07XG5cdFx0aWYgKGl0ZW0pIHtcblx0XHRcdGNhbGxiYWNrKG5hbWUsIGludGVybmFsR2V0SWNvbkRhdGEoZGF0YSwgbmFtZSwgaXRlbSkpO1xuXHRcdFx0bmFtZXMucHVzaChuYW1lKTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIG5hbWVzO1xufVxuXG4vKipcbiogT3B0aW9uYWwgcHJvcGVydGllc1xuKi9cbmNvbnN0IG9wdGlvbmFsUHJvcGVydHlEZWZhdWx0cyA9IHtcblx0cHJvdmlkZXI6IFwiXCIsXG5cdGFsaWFzZXM6IHt9LFxuXHRub3RfZm91bmQ6IHt9LFxuXHQuLi5kZWZhdWx0SWNvbkRpbWVuc2lvbnNcbn07XG4vKipcbiogQ2hlY2sgcHJvcHNcbiovXG5mdW5jdGlvbiBjaGVja09wdGlvbmFsUHJvcHMoaXRlbSwgZGVmYXVsdHMpIHtcblx0Zm9yIChjb25zdCBwcm9wIGluIGRlZmF1bHRzKSBpZiAocHJvcCBpbiBpdGVtICYmIHR5cGVvZiBpdGVtW3Byb3BdICE9PSB0eXBlb2YgZGVmYXVsdHNbcHJvcF0pIHJldHVybiBmYWxzZTtcblx0cmV0dXJuIHRydWU7XG59XG4vKipcbiogVmFsaWRhdGUgaWNvbiBzZXQsIHJldHVybiBpdCBhcyBJY29uaWZ5SlNPTiBvbiBzdWNjZXNzLCBudWxsIG9uIGZhaWx1cmVcbipcbiogVW5saWtlIHZhbGlkYXRlSWNvblNldCgpLCB0aGlzIGZ1bmN0aW9uIGlzIHZlcnkgYmFzaWMuXG4qIEl0IGRvZXMgbm90IHRocm93IGV4Y2VwdGlvbnMsIGl0IGRvZXMgbm90IGNoZWNrIG1ldGFkYXRhLCBpdCBkb2VzIG5vdCBmaXggc3R1ZmYuXG4qL1xuZnVuY3Rpb24gcXVpY2tseVZhbGlkYXRlSWNvblNldChvYmopIHtcblx0aWYgKHR5cGVvZiBvYmogIT09IFwib2JqZWN0XCIgfHwgb2JqID09PSBudWxsKSByZXR1cm4gbnVsbDtcblx0Y29uc3QgZGF0YSA9IG9iajtcblx0aWYgKHR5cGVvZiBkYXRhLnByZWZpeCAhPT0gXCJzdHJpbmdcIiB8fCAhb2JqLmljb25zIHx8IHR5cGVvZiBvYmouaWNvbnMgIT09IFwib2JqZWN0XCIpIHJldHVybiBudWxsO1xuXHRpZiAoIWNoZWNrT3B0aW9uYWxQcm9wcyhvYmosIG9wdGlvbmFsUHJvcGVydHlEZWZhdWx0cykpIHJldHVybiBudWxsO1xuXHRjb25zdCBpY29ucyA9IGRhdGEuaWNvbnM7XG5cdGZvciAoY29uc3QgbmFtZSBpbiBpY29ucykge1xuXHRcdGNvbnN0IGljb24gPSBpY29uc1tuYW1lXTtcblx0XHRpZiAoIW5hbWUgfHwgdHlwZW9mIGljb24uYm9keSAhPT0gXCJzdHJpbmdcIiB8fCAhY2hlY2tPcHRpb25hbFByb3BzKGljb24sIGRlZmF1bHRFeHRlbmRlZEljb25Qcm9wcykpIHJldHVybiBudWxsO1xuXHR9XG5cdGNvbnN0IGFsaWFzZXMgPSBkYXRhLmFsaWFzZXMgfHwgT2JqZWN0LmNyZWF0ZShudWxsKTtcblx0Zm9yIChjb25zdCBuYW1lIGluIGFsaWFzZXMpIHtcblx0XHRjb25zdCBpY29uID0gYWxpYXNlc1tuYW1lXTtcblx0XHRjb25zdCBwYXJlbnQgPSBpY29uLnBhcmVudDtcblx0XHRpZiAoIW5hbWUgfHwgdHlwZW9mIHBhcmVudCAhPT0gXCJzdHJpbmdcIiB8fCAhaWNvbnNbcGFyZW50XSAmJiAhYWxpYXNlc1twYXJlbnRdIHx8ICFjaGVja09wdGlvbmFsUHJvcHMoaWNvbiwgZGVmYXVsdEV4dGVuZGVkSWNvblByb3BzKSkgcmV0dXJuIG51bGw7XG5cdH1cblx0cmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuKiBTdG9yYWdlIGJ5IHByb3ZpZGVyIGFuZCBwcmVmaXhcbiovXG5jb25zdCBkYXRhU3RvcmFnZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4vKipcbiogQ3JlYXRlIG5ldyBzdG9yYWdlXG4qL1xuZnVuY3Rpb24gbmV3U3RvcmFnZShwcm92aWRlciwgcHJlZml4KSB7XG5cdHJldHVybiB7XG5cdFx0cHJvdmlkZXIsXG5cdFx0cHJlZml4LFxuXHRcdGljb25zOiBPYmplY3QuY3JlYXRlKG51bGwpLFxuXHRcdG1pc3Npbmc6IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KClcblx0fTtcbn1cbi8qKlxuKiBHZXQgc3RvcmFnZSBmb3IgcHJvdmlkZXIgYW5kIHByZWZpeFxuKi9cbmZ1bmN0aW9uIGdldFN0b3JhZ2UocHJvdmlkZXIsIHByZWZpeCkge1xuXHRjb25zdCBwcm92aWRlclN0b3JhZ2UgPSBkYXRhU3RvcmFnZVtwcm92aWRlcl0gfHwgKGRhdGFTdG9yYWdlW3Byb3ZpZGVyXSA9IE9iamVjdC5jcmVhdGUobnVsbCkpO1xuXHRyZXR1cm4gcHJvdmlkZXJTdG9yYWdlW3ByZWZpeF0gfHwgKHByb3ZpZGVyU3RvcmFnZVtwcmVmaXhdID0gbmV3U3RvcmFnZShwcm92aWRlciwgcHJlZml4KSk7XG59XG4vKipcbiogQWRkIGljb24gc2V0IHRvIHN0b3JhZ2VcbipcbiogUmV0dXJucyBhcnJheSBvZiBhZGRlZCBpY29uc1xuKi9cbmZ1bmN0aW9uIGFkZEljb25TZXQoc3RvcmFnZSwgZGF0YSkge1xuXHRpZiAoIXF1aWNrbHlWYWxpZGF0ZUljb25TZXQoZGF0YSkpIHJldHVybiBbXTtcblx0cmV0dXJuIHBhcnNlSWNvblNldChkYXRhLCAobmFtZSwgaWNvbikgPT4ge1xuXHRcdGlmIChpY29uKSBzdG9yYWdlLmljb25zW25hbWVdID0gaWNvbjtcblx0XHRlbHNlIHN0b3JhZ2UubWlzc2luZy5hZGQobmFtZSk7XG5cdH0pO1xufVxuLyoqXG4qIEFkZCBpY29uIHRvIHN0b3JhZ2VcbiovXG5mdW5jdGlvbiBhZGRJY29uVG9TdG9yYWdlKHN0b3JhZ2UsIG5hbWUsIGljb24pIHtcblx0dHJ5IHtcblx0XHRpZiAodHlwZW9mIGljb24uYm9keSA9PT0gXCJzdHJpbmdcIikge1xuXHRcdFx0c3RvcmFnZS5pY29uc1tuYW1lXSA9IHsgLi4uaWNvbiB9O1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHR9IGNhdGNoIChlcnIpIHt9XG5cdHJldHVybiBmYWxzZTtcbn1cbi8qKlxuKiBMaXN0IGF2YWlsYWJsZSBpY29uc1xuKi9cbmZ1bmN0aW9uIGxpc3RJY29ucyhwcm92aWRlciwgcHJlZml4KSB7XG5cdGxldCBhbGxJY29ucyA9IFtdO1xuXHRjb25zdCBwcm92aWRlcnMgPSB0eXBlb2YgcHJvdmlkZXIgPT09IFwic3RyaW5nXCIgPyBbcHJvdmlkZXJdIDogT2JqZWN0LmtleXMoZGF0YVN0b3JhZ2UpO1xuXHRwcm92aWRlcnMuZm9yRWFjaCgocHJvdmlkZXIkMSkgPT4ge1xuXHRcdGNvbnN0IHByZWZpeGVzID0gdHlwZW9mIHByb3ZpZGVyJDEgPT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIHByZWZpeCA9PT0gXCJzdHJpbmdcIiA/IFtwcmVmaXhdIDogT2JqZWN0LmtleXMoZGF0YVN0b3JhZ2VbcHJvdmlkZXIkMV0gfHwge30pO1xuXHRcdHByZWZpeGVzLmZvckVhY2goKHByZWZpeCQxKSA9PiB7XG5cdFx0XHRjb25zdCBzdG9yYWdlID0gZ2V0U3RvcmFnZShwcm92aWRlciQxLCBwcmVmaXgkMSk7XG5cdFx0XHRhbGxJY29ucyA9IGFsbEljb25zLmNvbmNhdChPYmplY3Qua2V5cyhzdG9yYWdlLmljb25zKS5tYXAoKG5hbWUpID0+IChwcm92aWRlciQxICE9PSBcIlwiID8gXCJAXCIgKyBwcm92aWRlciQxICsgXCI6XCIgOiBcIlwiKSArIHByZWZpeCQxICsgXCI6XCIgKyBuYW1lKSk7XG5cdFx0fSk7XG5cdH0pO1xuXHRyZXR1cm4gYWxsSWNvbnM7XG59XG5cbi8qKlxuKiBFeHByZXNzaW9uIHRvIHRlc3QgcGFydCBvZiBpY29uIG5hbWUuXG4qXG4qIFVzZWQgd2hlbiBsb2FkaW5nIGljb25zIGZyb20gSWNvbmlmeSBBUEkgZHVlIHRvIHByb2plY3QgbmFtaW5nIGNvbnZlbnNpb24uXG4qIElnbm9yZWQgd2hlbiB1c2luZyBjdXN0b20gaWNvbiBzZXRzIC0gY29udmVuc2lvbiBkb2VzIG5vdCBhcHBseS5cbiovXG5jb25zdCBtYXRjaEljb25OYW1lID0gL15bYS16MC05XSsoLVthLXowLTldKykqJC87XG4vKipcbiogQ29udmVydCBzdHJpbmcgaWNvbiBuYW1lIHRvIEljb25pZnlJY29uTmFtZSBvYmplY3QuXG4qL1xuY29uc3Qgc3RyaW5nVG9JY29uID0gKHZhbHVlLCB2YWxpZGF0ZSwgYWxsb3dTaW1wbGVOYW1lLCBwcm92aWRlciA9IFwiXCIpID0+IHtcblx0Y29uc3QgY29sb25TZXBhcmF0ZWQgPSB2YWx1ZS5zcGxpdChcIjpcIik7XG5cdGlmICh2YWx1ZS5zbGljZSgwLCAxKSA9PT0gXCJAXCIpIHtcblx0XHRpZiAoY29sb25TZXBhcmF0ZWQubGVuZ3RoIDwgMiB8fCBjb2xvblNlcGFyYXRlZC5sZW5ndGggPiAzKSByZXR1cm4gbnVsbDtcblx0XHRwcm92aWRlciA9IGNvbG9uU2VwYXJhdGVkLnNoaWZ0KCkuc2xpY2UoMSk7XG5cdH1cblx0aWYgKGNvbG9uU2VwYXJhdGVkLmxlbmd0aCA+IDMgfHwgIWNvbG9uU2VwYXJhdGVkLmxlbmd0aCkgcmV0dXJuIG51bGw7XG5cdGlmIChjb2xvblNlcGFyYXRlZC5sZW5ndGggPiAxKSB7XG5cdFx0Y29uc3QgbmFtZSQxID0gY29sb25TZXBhcmF0ZWQucG9wKCk7XG5cdFx0Y29uc3QgcHJlZml4ID0gY29sb25TZXBhcmF0ZWQucG9wKCk7XG5cdFx0Y29uc3QgcmVzdWx0ID0ge1xuXHRcdFx0cHJvdmlkZXI6IGNvbG9uU2VwYXJhdGVkLmxlbmd0aCA+IDAgPyBjb2xvblNlcGFyYXRlZFswXSA6IHByb3ZpZGVyLFxuXHRcdFx0cHJlZml4LFxuXHRcdFx0bmFtZTogbmFtZSQxXG5cdFx0fTtcblx0XHRyZXR1cm4gdmFsaWRhdGUgJiYgIXZhbGlkYXRlSWNvbk5hbWUocmVzdWx0KSA/IG51bGwgOiByZXN1bHQ7XG5cdH1cblx0Y29uc3QgbmFtZSA9IGNvbG9uU2VwYXJhdGVkWzBdO1xuXHRjb25zdCBkYXNoU2VwYXJhdGVkID0gbmFtZS5zcGxpdChcIi1cIik7XG5cdGlmIChkYXNoU2VwYXJhdGVkLmxlbmd0aCA+IDEpIHtcblx0XHRjb25zdCByZXN1bHQgPSB7XG5cdFx0XHRwcm92aWRlcixcblx0XHRcdHByZWZpeDogZGFzaFNlcGFyYXRlZC5zaGlmdCgpLFxuXHRcdFx0bmFtZTogZGFzaFNlcGFyYXRlZC5qb2luKFwiLVwiKVxuXHRcdH07XG5cdFx0cmV0dXJuIHZhbGlkYXRlICYmICF2YWxpZGF0ZUljb25OYW1lKHJlc3VsdCkgPyBudWxsIDogcmVzdWx0O1xuXHR9XG5cdGlmIChhbGxvd1NpbXBsZU5hbWUgJiYgcHJvdmlkZXIgPT09IFwiXCIpIHtcblx0XHRjb25zdCByZXN1bHQgPSB7XG5cdFx0XHRwcm92aWRlcixcblx0XHRcdHByZWZpeDogXCJcIixcblx0XHRcdG5hbWVcblx0XHR9O1xuXHRcdHJldHVybiB2YWxpZGF0ZSAmJiAhdmFsaWRhdGVJY29uTmFtZShyZXN1bHQsIGFsbG93U2ltcGxlTmFtZSkgPyBudWxsIDogcmVzdWx0O1xuXHR9XG5cdHJldHVybiBudWxsO1xufTtcbi8qKlxuKiBDaGVjayBpZiBpY29uIGlzIHZhbGlkLlxuKlxuKiBUaGlzIGZ1bmN0aW9uIGlzIG5vdCBwYXJ0IG9mIHN0cmluZ1RvSWNvbiBiZWNhdXNlIHZhbGlkYXRpb24gaXMgbm90IG5lZWRlZCBmb3IgbW9zdCBjb2RlLlxuKi9cbmNvbnN0IHZhbGlkYXRlSWNvbk5hbWUgPSAoaWNvbiwgYWxsb3dTaW1wbGVOYW1lKSA9PiB7XG5cdGlmICghaWNvbikgcmV0dXJuIGZhbHNlO1xuXHRyZXR1cm4gISEoKGFsbG93U2ltcGxlTmFtZSAmJiBpY29uLnByZWZpeCA9PT0gXCJcIiB8fCAhIWljb24ucHJlZml4KSAmJiAhIWljb24ubmFtZSk7XG59O1xuXG4vKipcbiogQWxsb3cgc3RvcmluZyBpY29ucyB3aXRob3V0IHByb3ZpZGVyIG9yIHByZWZpeCwgbWFraW5nIGl0IHBvc3NpYmxlIHRvIHN0b3JlIGljb25zIGxpa2UgXCJob21lXCJcbiovXG5sZXQgc2ltcGxlTmFtZXMgPSBmYWxzZTtcbmZ1bmN0aW9uIGFsbG93U2ltcGxlTmFtZXMoYWxsb3cpIHtcblx0aWYgKHR5cGVvZiBhbGxvdyA9PT0gXCJib29sZWFuXCIpIHNpbXBsZU5hbWVzID0gYWxsb3c7XG5cdHJldHVybiBzaW1wbGVOYW1lcztcbn1cbi8qKlxuKiBHZXQgaWNvbiBkYXRhXG4qXG4qIFJldHVybnM6XG4qIC0gSWNvbmlmeUljb24gb24gc3VjY2Vzcywgb2JqZWN0IGRpcmVjdGx5IGZyb20gc3RvcmFnZSBzbyBkb24ndCBtb2RpZnkgaXRcbiogLSBudWxsIGlmIGljb24gaXMgbWFya2VkIGFzIG1pc3NpbmcgKHJldHVybmVkIGluIGBub3RfZm91bmRgIHByb3BlcnR5IGZyb20gQVBJLCBzbyBkb24ndCBib3RoZXIgc2VuZGluZyBBUEkgcmVxdWVzdHMpXG4qIC0gdW5kZWZpbmVkIGlmIGljb24gaXMgbWlzc2luZyBpbiBzdG9yYWdlXG4qL1xuZnVuY3Rpb24gZ2V0SWNvbkRhdGEobmFtZSkge1xuXHRjb25zdCBpY29uID0gdHlwZW9mIG5hbWUgPT09IFwic3RyaW5nXCIgPyBzdHJpbmdUb0ljb24obmFtZSwgdHJ1ZSwgc2ltcGxlTmFtZXMpIDogbmFtZTtcblx0aWYgKGljb24pIHtcblx0XHRjb25zdCBzdG9yYWdlID0gZ2V0U3RvcmFnZShpY29uLnByb3ZpZGVyLCBpY29uLnByZWZpeCk7XG5cdFx0Y29uc3QgaWNvbk5hbWUgPSBpY29uLm5hbWU7XG5cdFx0cmV0dXJuIHN0b3JhZ2UuaWNvbnNbaWNvbk5hbWVdIHx8IChzdG9yYWdlLm1pc3NpbmcuaGFzKGljb25OYW1lKSA/IG51bGwgOiB2b2lkIDApO1xuXHR9XG59XG4vKipcbiogQWRkIG9uZSBpY29uXG4qL1xuZnVuY3Rpb24gYWRkSWNvbihuYW1lLCBkYXRhKSB7XG5cdGNvbnN0IGljb24gPSBzdHJpbmdUb0ljb24obmFtZSwgdHJ1ZSwgc2ltcGxlTmFtZXMpO1xuXHRpZiAoIWljb24pIHJldHVybiBmYWxzZTtcblx0Y29uc3Qgc3RvcmFnZSA9IGdldFN0b3JhZ2UoaWNvbi5wcm92aWRlciwgaWNvbi5wcmVmaXgpO1xuXHRpZiAoZGF0YSkgcmV0dXJuIGFkZEljb25Ub1N0b3JhZ2Uoc3RvcmFnZSwgaWNvbi5uYW1lLCBkYXRhKTtcblx0ZWxzZSB7XG5cdFx0c3RvcmFnZS5taXNzaW5nLmFkZChpY29uLm5hbWUpO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG59XG4vKipcbiogQWRkIGljb24gc2V0XG4qL1xuZnVuY3Rpb24gYWRkQ29sbGVjdGlvbihkYXRhLCBwcm92aWRlcikge1xuXHRpZiAodHlwZW9mIGRhdGEgIT09IFwib2JqZWN0XCIpIHJldHVybiBmYWxzZTtcblx0aWYgKHR5cGVvZiBwcm92aWRlciAhPT0gXCJzdHJpbmdcIikgcHJvdmlkZXIgPSBkYXRhLnByb3ZpZGVyIHx8IFwiXCI7XG5cdGlmIChzaW1wbGVOYW1lcyAmJiAhcHJvdmlkZXIgJiYgIWRhdGEucHJlZml4KSB7XG5cdFx0bGV0IGFkZGVkID0gZmFsc2U7XG5cdFx0aWYgKHF1aWNrbHlWYWxpZGF0ZUljb25TZXQoZGF0YSkpIHtcblx0XHRcdGRhdGEucHJlZml4ID0gXCJcIjtcblx0XHRcdHBhcnNlSWNvblNldChkYXRhLCAobmFtZSwgaWNvbikgPT4ge1xuXHRcdFx0XHRpZiAoYWRkSWNvbihuYW1lLCBpY29uKSkgYWRkZWQgPSB0cnVlO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHRcdHJldHVybiBhZGRlZDtcblx0fVxuXHRjb25zdCBwcmVmaXggPSBkYXRhLnByZWZpeDtcblx0aWYgKCF2YWxpZGF0ZUljb25OYW1lKHtcblx0XHRwcmVmaXgsXG5cdFx0bmFtZTogXCJhXCJcblx0fSkpIHJldHVybiBmYWxzZTtcblx0Y29uc3Qgc3RvcmFnZSA9IGdldFN0b3JhZ2UocHJvdmlkZXIsIHByZWZpeCk7XG5cdHJldHVybiAhIWFkZEljb25TZXQoc3RvcmFnZSwgZGF0YSk7XG59XG4vKipcbiogQ2hlY2sgaWYgaWNvbiBkYXRhIGlzIGF2YWlsYWJsZVxuKi9cbmZ1bmN0aW9uIGljb25Mb2FkZWQobmFtZSkge1xuXHRyZXR1cm4gISFnZXRJY29uRGF0YShuYW1lKTtcbn1cbi8qKlxuKiBHZXQgZnVsbCBpY29uXG4qL1xuZnVuY3Rpb24gZ2V0SWNvbihuYW1lKSB7XG5cdGNvbnN0IHJlc3VsdCA9IGdldEljb25EYXRhKG5hbWUpO1xuXHRyZXR1cm4gcmVzdWx0ID8ge1xuXHRcdC4uLmRlZmF1bHRJY29uUHJvcHMsXG5cdFx0Li4ucmVzdWx0XG5cdH0gOiByZXN1bHQ7XG59XG5cbi8qKlxuKiBEZWZhdWx0IGljb24gY3VzdG9taXNhdGlvbnMgdmFsdWVzXG4qL1xuY29uc3QgZGVmYXVsdEljb25TaXplQ3VzdG9taXNhdGlvbnMgPSBPYmplY3QuZnJlZXplKHtcblx0d2lkdGg6IG51bGwsXG5cdGhlaWdodDogbnVsbFxufSk7XG5jb25zdCBkZWZhdWx0SWNvbkN1c3RvbWlzYXRpb25zID0gT2JqZWN0LmZyZWV6ZSh7XG5cdC4uLmRlZmF1bHRJY29uU2l6ZUN1c3RvbWlzYXRpb25zLFxuXHQuLi5kZWZhdWx0SWNvblRyYW5zZm9ybWF0aW9uc1xufSk7XG5cbi8qKlxuKiBSZWd1bGFyIGV4cHJlc3Npb25zIGZvciBjYWxjdWxhdGluZyBkaW1lbnNpb25zXG4qL1xuY29uc3QgdW5pdHNTcGxpdCA9IC8oLT9bMC05Ll0qWzAtOV0rWzAtOS5dKikvZztcbmNvbnN0IHVuaXRzVGVzdCA9IC9eLT9bMC05Ll0qWzAtOV0rWzAtOS5dKiQvZztcbmZ1bmN0aW9uIGNhbGN1bGF0ZVNpemUoc2l6ZSwgcmF0aW8sIHByZWNpc2lvbikge1xuXHRpZiAocmF0aW8gPT09IDEpIHJldHVybiBzaXplO1xuXHRwcmVjaXNpb24gPSBwcmVjaXNpb24gfHwgMTAwO1xuXHRpZiAodHlwZW9mIHNpemUgPT09IFwibnVtYmVyXCIpIHJldHVybiBNYXRoLmNlaWwoc2l6ZSAqIHJhdGlvICogcHJlY2lzaW9uKSAvIHByZWNpc2lvbjtcblx0aWYgKHR5cGVvZiBzaXplICE9PSBcInN0cmluZ1wiKSByZXR1cm4gc2l6ZTtcblx0Y29uc3Qgb2xkUGFydHMgPSBzaXplLnNwbGl0KHVuaXRzU3BsaXQpO1xuXHRpZiAob2xkUGFydHMgPT09IG51bGwgfHwgIW9sZFBhcnRzLmxlbmd0aCkgcmV0dXJuIHNpemU7XG5cdGNvbnN0IG5ld1BhcnRzID0gW107XG5cdGxldCBjb2RlID0gb2xkUGFydHMuc2hpZnQoKTtcblx0bGV0IGlzTnVtYmVyID0gdW5pdHNUZXN0LnRlc3QoY29kZSk7XG5cdHdoaWxlICh0cnVlKSB7XG5cdFx0aWYgKGlzTnVtYmVyKSB7XG5cdFx0XHRjb25zdCBudW0gPSBwYXJzZUZsb2F0KGNvZGUpO1xuXHRcdFx0aWYgKGlzTmFOKG51bSkpIG5ld1BhcnRzLnB1c2goY29kZSk7XG5cdFx0XHRlbHNlIG5ld1BhcnRzLnB1c2goTWF0aC5jZWlsKG51bSAqIHJhdGlvICogcHJlY2lzaW9uKSAvIHByZWNpc2lvbik7XG5cdFx0fSBlbHNlIG5ld1BhcnRzLnB1c2goY29kZSk7XG5cdFx0Y29kZSA9IG9sZFBhcnRzLnNoaWZ0KCk7XG5cdFx0aWYgKGNvZGUgPT09IHZvaWQgMCkgcmV0dXJuIG5ld1BhcnRzLmpvaW4oXCJcIik7XG5cdFx0aXNOdW1iZXIgPSAhaXNOdW1iZXI7XG5cdH1cbn1cblxuZnVuY3Rpb24gc3BsaXRTVkdEZWZzKGNvbnRlbnQsIHRhZyA9IFwiZGVmc1wiKSB7XG5cdGxldCBkZWZzID0gXCJcIjtcblx0Y29uc3QgaW5kZXggPSBjb250ZW50LmluZGV4T2YoXCI8XCIgKyB0YWcpO1xuXHR3aGlsZSAoaW5kZXggPj0gMCkge1xuXHRcdGNvbnN0IHN0YXJ0ID0gY29udGVudC5pbmRleE9mKFwiPlwiLCBpbmRleCk7XG5cdFx0Y29uc3QgZW5kID0gY29udGVudC5pbmRleE9mKFwiPC9cIiArIHRhZyk7XG5cdFx0aWYgKHN0YXJ0ID09PSAtMSB8fCBlbmQgPT09IC0xKSBicmVhaztcblx0XHRjb25zdCBlbmRFbmQgPSBjb250ZW50LmluZGV4T2YoXCI+XCIsIGVuZCk7XG5cdFx0aWYgKGVuZEVuZCA9PT0gLTEpIGJyZWFrO1xuXHRcdGRlZnMgKz0gY29udGVudC5zbGljZShzdGFydCArIDEsIGVuZCkudHJpbSgpO1xuXHRcdGNvbnRlbnQgPSBjb250ZW50LnNsaWNlKDAsIGluZGV4KS50cmltKCkgKyBjb250ZW50LnNsaWNlKGVuZEVuZCArIDEpO1xuXHR9XG5cdHJldHVybiB7XG5cdFx0ZGVmcyxcblx0XHRjb250ZW50XG5cdH07XG59XG4vKipcbiogTWVyZ2UgZGVmcyBhbmQgY29udGVudFxuKi9cbmZ1bmN0aW9uIG1lcmdlRGVmc0FuZENvbnRlbnQoZGVmcywgY29udGVudCkge1xuXHRyZXR1cm4gZGVmcyA/IFwiPGRlZnM+XCIgKyBkZWZzICsgXCI8L2RlZnM+XCIgKyBjb250ZW50IDogY29udGVudDtcbn1cbi8qKlxuKiBXcmFwIFNWRyBjb250ZW50LCB3aXRob3V0IHdyYXBwaW5nIGRlZmluaXRpb25zXG4qL1xuZnVuY3Rpb24gd3JhcFNWR0NvbnRlbnQoYm9keSwgc3RhcnQsIGVuZCkge1xuXHRjb25zdCBzcGxpdCA9IHNwbGl0U1ZHRGVmcyhib2R5KTtcblx0cmV0dXJuIG1lcmdlRGVmc0FuZENvbnRlbnQoc3BsaXQuZGVmcywgc3RhcnQgKyBzcGxpdC5jb250ZW50ICsgZW5kKTtcbn1cblxuLyoqXG4qIENoZWNrIGlmIHZhbHVlIHNob3VsZCBiZSB1bnNldC4gQWxsb3dzIG11bHRpcGxlIGtleXdvcmRzXG4qL1xuY29uc3QgaXNVbnNldEtleXdvcmQgPSAodmFsdWUpID0+IHZhbHVlID09PSBcInVuc2V0XCIgfHwgdmFsdWUgPT09IFwidW5kZWZpbmVkXCIgfHwgdmFsdWUgPT09IFwibm9uZVwiO1xuLyoqXG4qIEdldCBTVkcgYXR0cmlidXRlcyBhbmQgY29udGVudCBmcm9tIGljb24gKyBjdXN0b21pc2F0aW9uc1xuKlxuKiBEb2VzIG5vdCBnZW5lcmF0ZSBzdHlsZSB0byBtYWtlIGl0IGNvbXBhdGlibGUgd2l0aCBmcmFtZXdvcmtzIHRoYXQgdXNlIG9iamVjdHMgZm9yIHN0eWxlLCBzdWNoIGFzIFJlYWN0LlxuKiBJbnN0ZWFkLCBpdCBnZW5lcmF0ZXMgJ2lubGluZScgdmFsdWUuIElmIHRydWUsIHJlbmRlcmluZyBlbmdpbmUgc2hvdWxkIGFkZCB2ZXJ0aWNhbEFsaWduOiAtMC4xMjVlbSB0byBpY29uLlxuKlxuKiBDdXN0b21pc2F0aW9ucyBzaG91bGQgYmUgbm9ybWFsaXNlZCBieSBwbGF0Zm9ybSBzcGVjaWZpYyBwYXJzZXIuXG4qIFJlc3VsdCBzaG91bGQgYmUgY29udmVydGVkIHRvIDxzdmc+IGJ5IHBsYXRmb3JtIHNwZWNpZmljIHBhcnNlci5cbiogVXNlIHJlcGxhY2VJRHMgdG8gZ2VuZXJhdGUgdW5pcXVlIElEcyBmb3IgYm9keS5cbiovXG5mdW5jdGlvbiBpY29uVG9TVkcoaWNvbiwgY3VzdG9taXNhdGlvbnMpIHtcblx0Y29uc3QgZnVsbEljb24gPSB7XG5cdFx0Li4uZGVmYXVsdEljb25Qcm9wcyxcblx0XHQuLi5pY29uXG5cdH07XG5cdGNvbnN0IGZ1bGxDdXN0b21pc2F0aW9ucyA9IHtcblx0XHQuLi5kZWZhdWx0SWNvbkN1c3RvbWlzYXRpb25zLFxuXHRcdC4uLmN1c3RvbWlzYXRpb25zXG5cdH07XG5cdGNvbnN0IGJveCA9IHtcblx0XHRsZWZ0OiBmdWxsSWNvbi5sZWZ0LFxuXHRcdHRvcDogZnVsbEljb24udG9wLFxuXHRcdHdpZHRoOiBmdWxsSWNvbi53aWR0aCxcblx0XHRoZWlnaHQ6IGZ1bGxJY29uLmhlaWdodFxuXHR9O1xuXHRsZXQgYm9keSA9IGZ1bGxJY29uLmJvZHk7XG5cdFtmdWxsSWNvbiwgZnVsbEN1c3RvbWlzYXRpb25zXS5mb3JFYWNoKChwcm9wcykgPT4ge1xuXHRcdGNvbnN0IHRyYW5zZm9ybWF0aW9ucyA9IFtdO1xuXHRcdGNvbnN0IGhGbGlwID0gcHJvcHMuaEZsaXA7XG5cdFx0Y29uc3QgdkZsaXAgPSBwcm9wcy52RmxpcDtcblx0XHRsZXQgcm90YXRpb24gPSBwcm9wcy5yb3RhdGU7XG5cdFx0aWYgKGhGbGlwKSBpZiAodkZsaXApIHJvdGF0aW9uICs9IDI7XG5cdFx0ZWxzZSB7XG5cdFx0XHR0cmFuc2Zvcm1hdGlvbnMucHVzaChcInRyYW5zbGF0ZShcIiArIChib3gud2lkdGggKyBib3gubGVmdCkudG9TdHJpbmcoKSArIFwiIFwiICsgKDAgLSBib3gudG9wKS50b1N0cmluZygpICsgXCIpXCIpO1xuXHRcdFx0dHJhbnNmb3JtYXRpb25zLnB1c2goXCJzY2FsZSgtMSAxKVwiKTtcblx0XHRcdGJveC50b3AgPSBib3gubGVmdCA9IDA7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKHZGbGlwKSB7XG5cdFx0XHR0cmFuc2Zvcm1hdGlvbnMucHVzaChcInRyYW5zbGF0ZShcIiArICgwIC0gYm94LmxlZnQpLnRvU3RyaW5nKCkgKyBcIiBcIiArIChib3guaGVpZ2h0ICsgYm94LnRvcCkudG9TdHJpbmcoKSArIFwiKVwiKTtcblx0XHRcdHRyYW5zZm9ybWF0aW9ucy5wdXNoKFwic2NhbGUoMSAtMSlcIik7XG5cdFx0XHRib3gudG9wID0gYm94LmxlZnQgPSAwO1xuXHRcdH1cblx0XHRsZXQgdGVtcFZhbHVlO1xuXHRcdGlmIChyb3RhdGlvbiA8IDApIHJvdGF0aW9uIC09IE1hdGguZmxvb3Iocm90YXRpb24gLyA0KSAqIDQ7XG5cdFx0cm90YXRpb24gPSByb3RhdGlvbiAlIDQ7XG5cdFx0c3dpdGNoIChyb3RhdGlvbikge1xuXHRcdFx0Y2FzZSAxOlxuXHRcdFx0XHR0ZW1wVmFsdWUgPSBib3guaGVpZ2h0IC8gMiArIGJveC50b3A7XG5cdFx0XHRcdHRyYW5zZm9ybWF0aW9ucy51bnNoaWZ0KFwicm90YXRlKDkwIFwiICsgdGVtcFZhbHVlLnRvU3RyaW5nKCkgKyBcIiBcIiArIHRlbXBWYWx1ZS50b1N0cmluZygpICsgXCIpXCIpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgMjpcblx0XHRcdFx0dHJhbnNmb3JtYXRpb25zLnVuc2hpZnQoXCJyb3RhdGUoMTgwIFwiICsgKGJveC53aWR0aCAvIDIgKyBib3gubGVmdCkudG9TdHJpbmcoKSArIFwiIFwiICsgKGJveC5oZWlnaHQgLyAyICsgYm94LnRvcCkudG9TdHJpbmcoKSArIFwiKVwiKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIDM6XG5cdFx0XHRcdHRlbXBWYWx1ZSA9IGJveC53aWR0aCAvIDIgKyBib3gubGVmdDtcblx0XHRcdFx0dHJhbnNmb3JtYXRpb25zLnVuc2hpZnQoXCJyb3RhdGUoLTkwIFwiICsgdGVtcFZhbHVlLnRvU3RyaW5nKCkgKyBcIiBcIiArIHRlbXBWYWx1ZS50b1N0cmluZygpICsgXCIpXCIpO1xuXHRcdFx0XHRicmVhaztcblx0XHR9XG5cdFx0aWYgKHJvdGF0aW9uICUgMiA9PT0gMSkge1xuXHRcdFx0aWYgKGJveC5sZWZ0ICE9PSBib3gudG9wKSB7XG5cdFx0XHRcdHRlbXBWYWx1ZSA9IGJveC5sZWZ0O1xuXHRcdFx0XHRib3gubGVmdCA9IGJveC50b3A7XG5cdFx0XHRcdGJveC50b3AgPSB0ZW1wVmFsdWU7XG5cdFx0XHR9XG5cdFx0XHRpZiAoYm94LndpZHRoICE9PSBib3guaGVpZ2h0KSB7XG5cdFx0XHRcdHRlbXBWYWx1ZSA9IGJveC53aWR0aDtcblx0XHRcdFx0Ym94LndpZHRoID0gYm94LmhlaWdodDtcblx0XHRcdFx0Ym94LmhlaWdodCA9IHRlbXBWYWx1ZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKHRyYW5zZm9ybWF0aW9ucy5sZW5ndGgpIGJvZHkgPSB3cmFwU1ZHQ29udGVudChib2R5LCBcIjxnIHRyYW5zZm9ybT1cXFwiXCIgKyB0cmFuc2Zvcm1hdGlvbnMuam9pbihcIiBcIikgKyBcIlxcXCI+XCIsIFwiPC9nPlwiKTtcblx0fSk7XG5cdGNvbnN0IGN1c3RvbWlzYXRpb25zV2lkdGggPSBmdWxsQ3VzdG9taXNhdGlvbnMud2lkdGg7XG5cdGNvbnN0IGN1c3RvbWlzYXRpb25zSGVpZ2h0ID0gZnVsbEN1c3RvbWlzYXRpb25zLmhlaWdodDtcblx0Y29uc3QgYm94V2lkdGggPSBib3gud2lkdGg7XG5cdGNvbnN0IGJveEhlaWdodCA9IGJveC5oZWlnaHQ7XG5cdGxldCB3aWR0aDtcblx0bGV0IGhlaWdodDtcblx0aWYgKGN1c3RvbWlzYXRpb25zV2lkdGggPT09IG51bGwpIHtcblx0XHRoZWlnaHQgPSBjdXN0b21pc2F0aW9uc0hlaWdodCA9PT0gbnVsbCA/IFwiMWVtXCIgOiBjdXN0b21pc2F0aW9uc0hlaWdodCA9PT0gXCJhdXRvXCIgPyBib3hIZWlnaHQgOiBjdXN0b21pc2F0aW9uc0hlaWdodDtcblx0XHR3aWR0aCA9IGNhbGN1bGF0ZVNpemUoaGVpZ2h0LCBib3hXaWR0aCAvIGJveEhlaWdodCk7XG5cdH0gZWxzZSB7XG5cdFx0d2lkdGggPSBjdXN0b21pc2F0aW9uc1dpZHRoID09PSBcImF1dG9cIiA/IGJveFdpZHRoIDogY3VzdG9taXNhdGlvbnNXaWR0aDtcblx0XHRoZWlnaHQgPSBjdXN0b21pc2F0aW9uc0hlaWdodCA9PT0gbnVsbCA/IGNhbGN1bGF0ZVNpemUod2lkdGgsIGJveEhlaWdodCAvIGJveFdpZHRoKSA6IGN1c3RvbWlzYXRpb25zSGVpZ2h0ID09PSBcImF1dG9cIiA/IGJveEhlaWdodCA6IGN1c3RvbWlzYXRpb25zSGVpZ2h0O1xuXHR9XG5cdGNvbnN0IGF0dHJpYnV0ZXMgPSB7fTtcblx0Y29uc3Qgc2V0QXR0ciA9IChwcm9wLCB2YWx1ZSkgPT4ge1xuXHRcdGlmICghaXNVbnNldEtleXdvcmQodmFsdWUpKSBhdHRyaWJ1dGVzW3Byb3BdID0gdmFsdWUudG9TdHJpbmcoKTtcblx0fTtcblx0c2V0QXR0cihcIndpZHRoXCIsIHdpZHRoKTtcblx0c2V0QXR0cihcImhlaWdodFwiLCBoZWlnaHQpO1xuXHRjb25zdCB2aWV3Qm94ID0gW1xuXHRcdGJveC5sZWZ0LFxuXHRcdGJveC50b3AsXG5cdFx0Ym94V2lkdGgsXG5cdFx0Ym94SGVpZ2h0XG5cdF07XG5cdGF0dHJpYnV0ZXMudmlld0JveCA9IHZpZXdCb3guam9pbihcIiBcIik7XG5cdHJldHVybiB7XG5cdFx0YXR0cmlidXRlcyxcblx0XHR2aWV3Qm94LFxuXHRcdGJvZHlcblx0fTtcbn1cblxuLyoqXG4qIElEcyB1c2FnZTpcbipcbiogaWQ9XCJ7aWR9XCJcbiogeGxpbms6aHJlZj1cIiN7aWR9XCJcbiogdXJsKCN7aWR9KVxuKlxuKiBGcm9tIFNWRyBhbmltYXRpb25zOlxuKlxuKiBiZWdpbj1cIjA7e2lkfS5lbmRcIlxuKiBiZWdpbj1cIntpZH0uZW5kXCJcbiogYmVnaW49XCJ7aWR9LmNsaWNrXCJcbiovXG4vKipcbiogUmVndWxhciBleHByZXNzaW9uIGZvciBmaW5kaW5nIGlkc1xuKi9cbmNvbnN0IHJlZ2V4ID0gL1xcc2lkPVwiKFxcUyspXCIvZztcbi8qKlxuKiBOZXcgcmFuZG9tLWlzaCBwcmVmaXggZm9yIGlkc1xuKlxuKiBEbyBub3QgdXNlIGRhc2gsIGl0IGNhbm5vdCBiZSB1c2VkIGluIFNWRyAyIGFuaW1hdGlvbnNcbiovXG5jb25zdCByYW5kb21QcmVmaXggPSBcIkljb25pZnlJZFwiICsgRGF0ZS5ub3coKS50b1N0cmluZygxNikgKyAoTWF0aC5yYW5kb20oKSAqIDE2Nzc3MjE2IHwgMCkudG9TdHJpbmcoMTYpO1xuLyoqXG4qIENvdW50ZXIgZm9yIGlkcywgaW5jcmVhc2luZyB3aXRoIGV2ZXJ5IHJlcGxhY2VtZW50XG4qL1xubGV0IGNvdW50ZXIgPSAwO1xuLyoqXG4qIFJlcGxhY2UgSURzIGluIFNWRyBvdXRwdXQgd2l0aCB1bmlxdWUgSURzXG4qL1xuZnVuY3Rpb24gcmVwbGFjZUlEcyhib2R5LCBwcmVmaXggPSByYW5kb21QcmVmaXgpIHtcblx0Y29uc3QgaWRzID0gW107XG5cdGxldCBtYXRjaDtcblx0d2hpbGUgKG1hdGNoID0gcmVnZXguZXhlYyhib2R5KSkgaWRzLnB1c2gobWF0Y2hbMV0pO1xuXHRpZiAoIWlkcy5sZW5ndGgpIHJldHVybiBib2R5O1xuXHRjb25zdCBzdWZmaXggPSBcInN1ZmZpeFwiICsgKE1hdGgucmFuZG9tKCkgKiAxNjc3NzIxNiB8IERhdGUubm93KCkpLnRvU3RyaW5nKDE2KTtcblx0aWRzLmZvckVhY2goKGlkKSA9PiB7XG5cdFx0Y29uc3QgbmV3SUQgPSB0eXBlb2YgcHJlZml4ID09PSBcImZ1bmN0aW9uXCIgPyBwcmVmaXgoaWQpIDogcHJlZml4ICsgKGNvdW50ZXIrKykudG9TdHJpbmcoKTtcblx0XHRjb25zdCBlc2NhcGVkSUQgPSBpZC5yZXBsYWNlKC9bLiorP14ke30oKXxbXFxdXFxcXF0vZywgXCJcXFxcJCZcIik7XG5cdFx0Ym9keSA9IGJvZHkucmVwbGFjZShuZXcgUmVnRXhwKFwiKFsjO1xcXCJdKShcIiArIGVzY2FwZWRJRCArIFwiKShbXFxcIildfFxcXFwuW2Etel0pXCIsIFwiZ1wiKSwgXCIkMVwiICsgbmV3SUQgKyBzdWZmaXggKyBcIiQzXCIpO1xuXHR9KTtcblx0Ym9keSA9IGJvZHkucmVwbGFjZShuZXcgUmVnRXhwKHN1ZmZpeCwgXCJnXCIpLCBcIlwiKTtcblx0cmV0dXJuIGJvZHk7XG59XG5cbi8qKlxuKiBMb2NhbCBzdG9yYXRlIHR5cGVzIGFuZCBlbnRyaWVzXG4qL1xuY29uc3Qgc3RvcmFnZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4vKipcbiogU2V0IEFQSSBtb2R1bGVcbiovXG5mdW5jdGlvbiBzZXRBUElNb2R1bGUocHJvdmlkZXIsIGl0ZW0pIHtcblx0c3RvcmFnZVtwcm92aWRlcl0gPSBpdGVtO1xufVxuLyoqXG4qIEdldCBBUEkgbW9kdWxlXG4qL1xuZnVuY3Rpb24gZ2V0QVBJTW9kdWxlKHByb3ZpZGVyKSB7XG5cdHJldHVybiBzdG9yYWdlW3Byb3ZpZGVyXSB8fCBzdG9yYWdlW1wiXCJdO1xufVxuXG4vKipcbiogQ3JlYXRlIGZ1bGwgQVBJIGNvbmZpZ3VyYXRpb24gZnJvbSBwYXJ0aWFsIGRhdGFcbiovXG5mdW5jdGlvbiBjcmVhdGVBUElDb25maWcoc291cmNlKSB7XG5cdGxldCByZXNvdXJjZXM7XG5cdGlmICh0eXBlb2Ygc291cmNlLnJlc291cmNlcyA9PT0gXCJzdHJpbmdcIikgcmVzb3VyY2VzID0gW3NvdXJjZS5yZXNvdXJjZXNdO1xuXHRlbHNlIHtcblx0XHRyZXNvdXJjZXMgPSBzb3VyY2UucmVzb3VyY2VzO1xuXHRcdGlmICghKHJlc291cmNlcyBpbnN0YW5jZW9mIEFycmF5KSB8fCAhcmVzb3VyY2VzLmxlbmd0aCkgcmV0dXJuIG51bGw7XG5cdH1cblx0Y29uc3QgcmVzdWx0ID0ge1xuXHRcdHJlc291cmNlcyxcblx0XHRwYXRoOiBzb3VyY2UucGF0aCB8fCBcIi9cIixcblx0XHRtYXhVUkw6IHNvdXJjZS5tYXhVUkwgfHwgNTAwLFxuXHRcdHJvdGF0ZTogc291cmNlLnJvdGF0ZSB8fCA3NTAsXG5cdFx0dGltZW91dDogc291cmNlLnRpbWVvdXQgfHwgNWUzLFxuXHRcdHJhbmRvbTogc291cmNlLnJhbmRvbSA9PT0gdHJ1ZSxcblx0XHRpbmRleDogc291cmNlLmluZGV4IHx8IDAsXG5cdFx0ZGF0YUFmdGVyVGltZW91dDogc291cmNlLmRhdGFBZnRlclRpbWVvdXQgIT09IGZhbHNlXG5cdH07XG5cdHJldHVybiByZXN1bHQ7XG59XG4vKipcbiogTG9jYWwgc3RvcmFnZVxuKi9cbmNvbnN0IGNvbmZpZ1N0b3JhZ2UgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuLyoqXG4qIFJlZHVuZGFuY3kgZm9yIEFQSSBzZXJ2ZXJzLlxuKlxuKiBBUEkgc2hvdWxkIGhhdmUgdmVyeSBoaWdoIHVwdGltZSBiZWNhdXNlIG9mIGltcGxlbWVudGVkIHJlZHVuZGFuY3kgYXQgc2VydmVyIGxldmVsLCBidXRcbiogc29tZXRpbWVzIGJhZCB0aGluZ3MgaGFwcGVuLiBPbiBpbnRlcm5ldCAxMDAlIHVwdGltZSBpcyBub3QgcG9zc2libGUuXG4qXG4qIFRoZXJlIGNvdWxkIGJlIHJvdXRpbmcgcHJvYmxlbXMuIFNlcnZlciBtaWdodCBnbyBkb3duIGZvciB3aGF0ZXZlciByZWFzb24sIGJ1dCBpdCB0YWtlc1xuKiBmZXcgbWludXRlcyB0byBkZXRlY3QgdGhhdCBkb3dudGltZSwgc28gZHVyaW5nIHRob3NlIGZldyBtaW51dGVzIEFQSSBtaWdodCBub3QgYmUgYWNjZXNzaWJsZS5cbipcbiogVGhpcyBzY3JpcHQgaGFzIHNvbWUgcmVkdW5kYW5jeSB0byBtaXRpZ2F0ZSBwb3NzaWJsZSBuZXR3b3JrIGlzc3Vlcy5cbipcbiogSWYgb25lIGhvc3QgY2Fubm90IGJlIHJlYWNoZWQgaW4gJ3JvdGF0ZScgKDc1MCBieSBkZWZhdWx0KSBtcywgc2NyaXB0IHdpbGwgdHJ5IHRvIHJldHJpZXZlXG4qIGRhdGEgZnJvbSBkaWZmZXJlbnQgaG9zdC4gSG9zdHMgaGF2ZSBkaWZmZXJlbnQgY29uZmlndXJhdGlvbnMsIHBvaW50aW5nIHRvIGRpZmZlcmVudFxuKiBBUEkgc2VydmVycyBob3N0ZWQgYXQgZGlmZmVyZW50IHByb3ZpZGVycy5cbiovXG5jb25zdCBmYWxsQmFja0FQSVNvdXJjZXMgPSBbXCJodHRwczovL2FwaS5zaW1wbGVzdmcuY29tXCIsIFwiaHR0cHM6Ly9hcGkudW5pc3ZnLmNvbVwiXTtcbmNvbnN0IGZhbGxCYWNrQVBJID0gW107XG53aGlsZSAoZmFsbEJhY2tBUElTb3VyY2VzLmxlbmd0aCA+IDApIGlmIChmYWxsQmFja0FQSVNvdXJjZXMubGVuZ3RoID09PSAxKSBmYWxsQmFja0FQSS5wdXNoKGZhbGxCYWNrQVBJU291cmNlcy5zaGlmdCgpKTtcbmVsc2UgaWYgKE1hdGgucmFuZG9tKCkgPiAuNSkgZmFsbEJhY2tBUEkucHVzaChmYWxsQmFja0FQSVNvdXJjZXMuc2hpZnQoKSk7XG5lbHNlIGZhbGxCYWNrQVBJLnB1c2goZmFsbEJhY2tBUElTb3VyY2VzLnBvcCgpKTtcbmNvbmZpZ1N0b3JhZ2VbXCJcIl0gPSBjcmVhdGVBUElDb25maWcoeyByZXNvdXJjZXM6IFtcImh0dHBzOi8vYXBpLmljb25pZnkuZGVzaWduXCJdLmNvbmNhdChmYWxsQmFja0FQSSkgfSk7XG4vKipcbiogQWRkIGN1c3RvbSBjb25maWcgZm9yIHByb3ZpZGVyXG4qL1xuZnVuY3Rpb24gYWRkQVBJUHJvdmlkZXIocHJvdmlkZXIsIGN1c3RvbUNvbmZpZykge1xuXHRjb25zdCBjb25maWcgPSBjcmVhdGVBUElDb25maWcoY3VzdG9tQ29uZmlnKTtcblx0aWYgKGNvbmZpZyA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuXHRjb25maWdTdG9yYWdlW3Byb3ZpZGVyXSA9IGNvbmZpZztcblx0cmV0dXJuIHRydWU7XG59XG4vKipcbiogR2V0IEFQSSBjb25maWd1cmF0aW9uXG4qL1xuZnVuY3Rpb24gZ2V0QVBJQ29uZmlnKHByb3ZpZGVyKSB7XG5cdHJldHVybiBjb25maWdTdG9yYWdlW3Byb3ZpZGVyXTtcbn1cbi8qKlxuKiBMaXN0IEFQSSBwcm92aWRlcnNcbiovXG5mdW5jdGlvbiBsaXN0QVBJUHJvdmlkZXJzKCkge1xuXHRyZXR1cm4gT2JqZWN0LmtleXMoY29uZmlnU3RvcmFnZSk7XG59XG5cbmNvbnN0IGRldGVjdEZldGNoID0gKCkgPT4ge1xuXHRsZXQgY2FsbGJhY2s7XG5cdHRyeSB7XG5cdFx0Y2FsbGJhY2sgPSBmZXRjaDtcblx0XHRpZiAodHlwZW9mIGNhbGxiYWNrID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBjYWxsYmFjaztcblx0fSBjYXRjaCAoZXJyKSB7fVxufTtcbi8qKlxuKiBGZXRjaCBmdW5jdGlvblxuKi9cbmxldCBmZXRjaE1vZHVsZSA9IGRldGVjdEZldGNoKCk7XG4vKipcbiogU2V0IGN1c3RvbSBmZXRjaCgpIGZ1bmN0aW9uXG4qL1xuZnVuY3Rpb24gc2V0RmV0Y2goZmV0Y2gkMSkge1xuXHRmZXRjaE1vZHVsZSA9IGZldGNoJDE7XG59XG4vKipcbiogR2V0IGZldGNoKCkgZnVuY3Rpb24uIFVzZWQgYnkgSWNvbiBGaW5kZXIgQ29yZVxuKi9cbmZ1bmN0aW9uIGdldEZldGNoKCkge1xuXHRyZXR1cm4gZmV0Y2hNb2R1bGU7XG59XG4vKipcbiogQ2FsY3VsYXRlIG1heGltdW0gaWNvbnMgbGlzdCBsZW5ndGggZm9yIHByZWZpeFxuKi9cbmZ1bmN0aW9uIGNhbGN1bGF0ZU1heExlbmd0aChwcm92aWRlciwgcHJlZml4KSB7XG5cdGNvbnN0IGNvbmZpZyA9IGdldEFQSUNvbmZpZyhwcm92aWRlcik7XG5cdGlmICghY29uZmlnKSByZXR1cm4gMDtcblx0bGV0IHJlc3VsdDtcblx0aWYgKCFjb25maWcubWF4VVJMKSByZXN1bHQgPSAwO1xuXHRlbHNlIHtcblx0XHRsZXQgbWF4SG9zdExlbmd0aCA9IDA7XG5cdFx0Y29uZmlnLnJlc291cmNlcy5mb3JFYWNoKChpdGVtKSA9PiB7XG5cdFx0XHRjb25zdCBob3N0ID0gaXRlbTtcblx0XHRcdG1heEhvc3RMZW5ndGggPSBNYXRoLm1heChtYXhIb3N0TGVuZ3RoLCBob3N0Lmxlbmd0aCk7XG5cdFx0fSk7XG5cdFx0Y29uc3QgdXJsID0gcHJlZml4ICsgXCIuanNvbj9pY29ucz1cIjtcblx0XHRyZXN1bHQgPSBjb25maWcubWF4VVJMIC0gbWF4SG9zdExlbmd0aCAtIGNvbmZpZy5wYXRoLmxlbmd0aCAtIHVybC5sZW5ndGg7XG5cdH1cblx0cmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuKiBTaG91bGQgcXVlcnkgYmUgYWJvcnRlZCwgYmFzZWQgb24gbGFzdCBIVFRQIHN0YXR1c1xuKi9cbmZ1bmN0aW9uIHNob3VsZEFib3J0KHN0YXR1cykge1xuXHRyZXR1cm4gc3RhdHVzID09PSA0MDQ7XG59XG4vKipcbiogUHJlcGFyZSBwYXJhbXNcbiovXG5jb25zdCBwcmVwYXJlID0gKHByb3ZpZGVyLCBwcmVmaXgsIGljb25zKSA9PiB7XG5cdGNvbnN0IHJlc3VsdHMgPSBbXTtcblx0Y29uc3QgbWF4TGVuZ3RoID0gY2FsY3VsYXRlTWF4TGVuZ3RoKHByb3ZpZGVyLCBwcmVmaXgpO1xuXHRjb25zdCB0eXBlID0gXCJpY29uc1wiO1xuXHRsZXQgaXRlbSA9IHtcblx0XHR0eXBlLFxuXHRcdHByb3ZpZGVyLFxuXHRcdHByZWZpeCxcblx0XHRpY29uczogW11cblx0fTtcblx0bGV0IGxlbmd0aCA9IDA7XG5cdGljb25zLmZvckVhY2goKG5hbWUsIGluZGV4KSA9PiB7XG5cdFx0bGVuZ3RoICs9IG5hbWUubGVuZ3RoICsgMTtcblx0XHRpZiAobGVuZ3RoID49IG1heExlbmd0aCAmJiBpbmRleCA+IDApIHtcblx0XHRcdHJlc3VsdHMucHVzaChpdGVtKTtcblx0XHRcdGl0ZW0gPSB7XG5cdFx0XHRcdHR5cGUsXG5cdFx0XHRcdHByb3ZpZGVyLFxuXHRcdFx0XHRwcmVmaXgsXG5cdFx0XHRcdGljb25zOiBbXVxuXHRcdFx0fTtcblx0XHRcdGxlbmd0aCA9IG5hbWUubGVuZ3RoO1xuXHRcdH1cblx0XHRpdGVtLmljb25zLnB1c2gobmFtZSk7XG5cdH0pO1xuXHRyZXN1bHRzLnB1c2goaXRlbSk7XG5cdHJldHVybiByZXN1bHRzO1xufTtcbi8qKlxuKiBHZXQgcGF0aFxuKi9cbmZ1bmN0aW9uIGdldFBhdGgocHJvdmlkZXIpIHtcblx0aWYgKHR5cGVvZiBwcm92aWRlciA9PT0gXCJzdHJpbmdcIikge1xuXHRcdGNvbnN0IGNvbmZpZyA9IGdldEFQSUNvbmZpZyhwcm92aWRlcik7XG5cdFx0aWYgKGNvbmZpZykgcmV0dXJuIGNvbmZpZy5wYXRoO1xuXHR9XG5cdHJldHVybiBcIi9cIjtcbn1cbi8qKlxuKiBMb2FkIGljb25zXG4qL1xuY29uc3Qgc2VuZCA9IChob3N0LCBwYXJhbXMsIGNhbGxiYWNrKSA9PiB7XG5cdGlmICghZmV0Y2hNb2R1bGUpIHtcblx0XHRjYWxsYmFjayhcImFib3J0XCIsIDQyNCk7XG5cdFx0cmV0dXJuO1xuXHR9XG5cdGxldCBwYXRoID0gZ2V0UGF0aChwYXJhbXMucHJvdmlkZXIpO1xuXHRzd2l0Y2ggKHBhcmFtcy50eXBlKSB7XG5cdFx0Y2FzZSBcImljb25zXCI6IHtcblx0XHRcdGNvbnN0IHByZWZpeCA9IHBhcmFtcy5wcmVmaXg7XG5cdFx0XHRjb25zdCBpY29ucyA9IHBhcmFtcy5pY29ucztcblx0XHRcdGNvbnN0IGljb25zTGlzdCA9IGljb25zLmpvaW4oXCIsXCIpO1xuXHRcdFx0Y29uc3QgdXJsUGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh7IGljb25zOiBpY29uc0xpc3QgfSk7XG5cdFx0XHRwYXRoICs9IHByZWZpeCArIFwiLmpzb24/XCIgKyB1cmxQYXJhbXMudG9TdHJpbmcoKTtcblx0XHRcdGJyZWFrO1xuXHRcdH1cblx0XHRjYXNlIFwiY3VzdG9tXCI6IHtcblx0XHRcdGNvbnN0IHVyaSA9IHBhcmFtcy51cmk7XG5cdFx0XHRwYXRoICs9IHVyaS5zbGljZSgwLCAxKSA9PT0gXCIvXCIgPyB1cmkuc2xpY2UoMSkgOiB1cmk7XG5cdFx0XHRicmVhaztcblx0XHR9XG5cdFx0ZGVmYXVsdDpcblx0XHRcdGNhbGxiYWNrKFwiYWJvcnRcIiwgNDAwKTtcblx0XHRcdHJldHVybjtcblx0fVxuXHRsZXQgZGVmYXVsdEVycm9yID0gNTAzO1xuXHRmZXRjaE1vZHVsZShob3N0ICsgcGF0aCkudGhlbigocmVzcG9uc2UpID0+IHtcblx0XHRjb25zdCBzdGF0dXMgPSByZXNwb25zZS5zdGF0dXM7XG5cdFx0aWYgKHN0YXR1cyAhPT0gMjAwKSB7XG5cdFx0XHRzZXRUaW1lb3V0KCgpID0+IHtcblx0XHRcdFx0Y2FsbGJhY2soc2hvdWxkQWJvcnQoc3RhdHVzKSA/IFwiYWJvcnRcIiA6IFwibmV4dFwiLCBzdGF0dXMpO1xuXHRcdFx0fSk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGRlZmF1bHRFcnJvciA9IDUwMTtcblx0XHRyZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuXHR9KS50aGVuKChkYXRhKSA9PiB7XG5cdFx0aWYgKHR5cGVvZiBkYXRhICE9PSBcIm9iamVjdFwiIHx8IGRhdGEgPT09IG51bGwpIHtcblx0XHRcdHNldFRpbWVvdXQoKCkgPT4ge1xuXHRcdFx0XHRpZiAoZGF0YSA9PT0gNDA0KSBjYWxsYmFjayhcImFib3J0XCIsIGRhdGEpO1xuXHRcdFx0XHRlbHNlIGNhbGxiYWNrKFwibmV4dFwiLCBkZWZhdWx0RXJyb3IpO1xuXHRcdFx0fSk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHNldFRpbWVvdXQoKCkgPT4ge1xuXHRcdFx0Y2FsbGJhY2soXCJzdWNjZXNzXCIsIGRhdGEpO1xuXHRcdH0pO1xuXHR9KS5jYXRjaCgoKSA9PiB7XG5cdFx0Y2FsbGJhY2soXCJuZXh0XCIsIGRlZmF1bHRFcnJvcik7XG5cdH0pO1xufTtcbi8qKlxuKiBFeHBvcnQgbW9kdWxlXG4qL1xuY29uc3QgZmV0Y2hBUElNb2R1bGUgPSB7XG5cdHByZXBhcmUsXG5cdHNlbmRcbn07XG5cbi8qKlxuKiBSZW1vdmUgY2FsbGJhY2tcbiovXG5mdW5jdGlvbiByZW1vdmVDYWxsYmFjayhzdG9yYWdlcywgaWQpIHtcblx0c3RvcmFnZXMuZm9yRWFjaCgoc3RvcmFnZSkgPT4ge1xuXHRcdGNvbnN0IGl0ZW1zID0gc3RvcmFnZS5sb2FkZXJDYWxsYmFja3M7XG5cdFx0aWYgKGl0ZW1zKSBzdG9yYWdlLmxvYWRlckNhbGxiYWNrcyA9IGl0ZW1zLmZpbHRlcigocm93KSA9PiByb3cuaWQgIT09IGlkKTtcblx0fSk7XG59XG4vKipcbiogVXBkYXRlIGFsbCBjYWxsYmFja3MgZm9yIHByb3ZpZGVyIGFuZCBwcmVmaXhcbiovXG5mdW5jdGlvbiB1cGRhdGVDYWxsYmFja3Moc3RvcmFnZSkge1xuXHRpZiAoIXN0b3JhZ2UucGVuZGluZ0NhbGxiYWNrc0ZsYWcpIHtcblx0XHRzdG9yYWdlLnBlbmRpbmdDYWxsYmFja3NGbGFnID0gdHJ1ZTtcblx0XHRzZXRUaW1lb3V0KCgpID0+IHtcblx0XHRcdHN0b3JhZ2UucGVuZGluZ0NhbGxiYWNrc0ZsYWcgPSBmYWxzZTtcblx0XHRcdGNvbnN0IGl0ZW1zID0gc3RvcmFnZS5sb2FkZXJDYWxsYmFja3MgPyBzdG9yYWdlLmxvYWRlckNhbGxiYWNrcy5zbGljZSgwKSA6IFtdO1xuXHRcdFx0aWYgKCFpdGVtcy5sZW5ndGgpIHJldHVybjtcblx0XHRcdGxldCBoYXNQZW5kaW5nID0gZmFsc2U7XG5cdFx0XHRjb25zdCBwcm92aWRlciA9IHN0b3JhZ2UucHJvdmlkZXI7XG5cdFx0XHRjb25zdCBwcmVmaXggPSBzdG9yYWdlLnByZWZpeDtcblx0XHRcdGl0ZW1zLmZvckVhY2goKGl0ZW0pID0+IHtcblx0XHRcdFx0Y29uc3QgaWNvbnMgPSBpdGVtLmljb25zO1xuXHRcdFx0XHRjb25zdCBvbGRMZW5ndGggPSBpY29ucy5wZW5kaW5nLmxlbmd0aDtcblx0XHRcdFx0aWNvbnMucGVuZGluZyA9IGljb25zLnBlbmRpbmcuZmlsdGVyKChpY29uKSA9PiB7XG5cdFx0XHRcdFx0aWYgKGljb24ucHJlZml4ICE9PSBwcmVmaXgpIHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdGNvbnN0IG5hbWUgPSBpY29uLm5hbWU7XG5cdFx0XHRcdFx0aWYgKHN0b3JhZ2UuaWNvbnNbbmFtZV0pIGljb25zLmxvYWRlZC5wdXNoKHtcblx0XHRcdFx0XHRcdHByb3ZpZGVyLFxuXHRcdFx0XHRcdFx0cHJlZml4LFxuXHRcdFx0XHRcdFx0bmFtZVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdGVsc2UgaWYgKHN0b3JhZ2UubWlzc2luZy5oYXMobmFtZSkpIGljb25zLm1pc3NpbmcucHVzaCh7XG5cdFx0XHRcdFx0XHRwcm92aWRlcixcblx0XHRcdFx0XHRcdHByZWZpeCxcblx0XHRcdFx0XHRcdG5hbWVcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdGhhc1BlbmRpbmcgPSB0cnVlO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fSk7XG5cdFx0XHRcdGlmIChpY29ucy5wZW5kaW5nLmxlbmd0aCAhPT0gb2xkTGVuZ3RoKSB7XG5cdFx0XHRcdFx0aWYgKCFoYXNQZW5kaW5nKSByZW1vdmVDYWxsYmFjayhbc3RvcmFnZV0sIGl0ZW0uaWQpO1xuXHRcdFx0XHRcdGl0ZW0uY2FsbGJhY2soaWNvbnMubG9hZGVkLnNsaWNlKDApLCBpY29ucy5taXNzaW5nLnNsaWNlKDApLCBpY29ucy5wZW5kaW5nLnNsaWNlKDApLCBpdGVtLmFib3J0KTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fSk7XG5cdH1cbn1cbi8qKlxuKiBVbmlxdWUgaWQgY291bnRlciBmb3IgY2FsbGJhY2tzXG4qL1xubGV0IGlkQ291bnRlciA9IDA7XG4vKipcbiogQWRkIGNhbGxiYWNrXG4qL1xuZnVuY3Rpb24gc3RvcmVDYWxsYmFjayhjYWxsYmFjaywgaWNvbnMsIHBlbmRpbmdTb3VyY2VzKSB7XG5cdGNvbnN0IGlkID0gaWRDb3VudGVyKys7XG5cdGNvbnN0IGFib3J0ID0gcmVtb3ZlQ2FsbGJhY2suYmluZChudWxsLCBwZW5kaW5nU291cmNlcywgaWQpO1xuXHRpZiAoIWljb25zLnBlbmRpbmcubGVuZ3RoKSByZXR1cm4gYWJvcnQ7XG5cdGNvbnN0IGl0ZW0gPSB7XG5cdFx0aWQsXG5cdFx0aWNvbnMsXG5cdFx0Y2FsbGJhY2ssXG5cdFx0YWJvcnRcblx0fTtcblx0cGVuZGluZ1NvdXJjZXMuZm9yRWFjaCgoc3RvcmFnZSkgPT4ge1xuXHRcdChzdG9yYWdlLmxvYWRlckNhbGxiYWNrcyB8fCAoc3RvcmFnZS5sb2FkZXJDYWxsYmFja3MgPSBbXSkpLnB1c2goaXRlbSk7XG5cdH0pO1xuXHRyZXR1cm4gYWJvcnQ7XG59XG5cbi8qKlxuKiBDaGVjayBpZiBpY29ucyBoYXZlIGJlZW4gbG9hZGVkXG4qL1xuZnVuY3Rpb24gc29ydEljb25zKGljb25zKSB7XG5cdGNvbnN0IHJlc3VsdCA9IHtcblx0XHRsb2FkZWQ6IFtdLFxuXHRcdG1pc3Npbmc6IFtdLFxuXHRcdHBlbmRpbmc6IFtdXG5cdH07XG5cdGNvbnN0IHN0b3JhZ2UgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXHRpY29ucy5zb3J0KChhLCBiKSA9PiB7XG5cdFx0aWYgKGEucHJvdmlkZXIgIT09IGIucHJvdmlkZXIpIHJldHVybiBhLnByb3ZpZGVyLmxvY2FsZUNvbXBhcmUoYi5wcm92aWRlcik7XG5cdFx0aWYgKGEucHJlZml4ICE9PSBiLnByZWZpeCkgcmV0dXJuIGEucHJlZml4LmxvY2FsZUNvbXBhcmUoYi5wcmVmaXgpO1xuXHRcdHJldHVybiBhLm5hbWUubG9jYWxlQ29tcGFyZShiLm5hbWUpO1xuXHR9KTtcblx0bGV0IGxhc3RJY29uID0ge1xuXHRcdHByb3ZpZGVyOiBcIlwiLFxuXHRcdHByZWZpeDogXCJcIixcblx0XHRuYW1lOiBcIlwiXG5cdH07XG5cdGljb25zLmZvckVhY2goKGljb24pID0+IHtcblx0XHRpZiAobGFzdEljb24ubmFtZSA9PT0gaWNvbi5uYW1lICYmIGxhc3RJY29uLnByZWZpeCA9PT0gaWNvbi5wcmVmaXggJiYgbGFzdEljb24ucHJvdmlkZXIgPT09IGljb24ucHJvdmlkZXIpIHJldHVybjtcblx0XHRsYXN0SWNvbiA9IGljb247XG5cdFx0Y29uc3QgcHJvdmlkZXIgPSBpY29uLnByb3ZpZGVyO1xuXHRcdGNvbnN0IHByZWZpeCA9IGljb24ucHJlZml4O1xuXHRcdGNvbnN0IG5hbWUgPSBpY29uLm5hbWU7XG5cdFx0Y29uc3QgcHJvdmlkZXJTdG9yYWdlID0gc3RvcmFnZVtwcm92aWRlcl0gfHwgKHN0b3JhZ2VbcHJvdmlkZXJdID0gT2JqZWN0LmNyZWF0ZShudWxsKSk7XG5cdFx0Y29uc3QgbG9jYWxTdG9yYWdlID0gcHJvdmlkZXJTdG9yYWdlW3ByZWZpeF0gfHwgKHByb3ZpZGVyU3RvcmFnZVtwcmVmaXhdID0gZ2V0U3RvcmFnZShwcm92aWRlciwgcHJlZml4KSk7XG5cdFx0bGV0IGxpc3Q7XG5cdFx0aWYgKG5hbWUgaW4gbG9jYWxTdG9yYWdlLmljb25zKSBsaXN0ID0gcmVzdWx0LmxvYWRlZDtcblx0XHRlbHNlIGlmIChwcmVmaXggPT09IFwiXCIgfHwgbG9jYWxTdG9yYWdlLm1pc3NpbmcuaGFzKG5hbWUpKSBsaXN0ID0gcmVzdWx0Lm1pc3Npbmc7XG5cdFx0ZWxzZSBsaXN0ID0gcmVzdWx0LnBlbmRpbmc7XG5cdFx0Y29uc3QgaXRlbSA9IHtcblx0XHRcdHByb3ZpZGVyLFxuXHRcdFx0cHJlZml4LFxuXHRcdFx0bmFtZVxuXHRcdH07XG5cdFx0bGlzdC5wdXNoKGl0ZW0pO1xuXHR9KTtcblx0cmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4qIENvbnZlcnQgaWNvbnMgbGlzdCBmcm9tIHN0cmluZy9pY29uIG1peCB0byBpY29ucyBhbmQgdmFsaWRhdGUgdGhlbVxuKi9cbmZ1bmN0aW9uIGxpc3RUb0ljb25zKGxpc3QsIHZhbGlkYXRlID0gdHJ1ZSwgc2ltcGxlTmFtZXMgPSBmYWxzZSkge1xuXHRjb25zdCByZXN1bHQgPSBbXTtcblx0bGlzdC5mb3JFYWNoKChpdGVtKSA9PiB7XG5cdFx0Y29uc3QgaWNvbiA9IHR5cGVvZiBpdGVtID09PSBcInN0cmluZ1wiID8gc3RyaW5nVG9JY29uKGl0ZW0sIHZhbGlkYXRlLCBzaW1wbGVOYW1lcykgOiBpdGVtO1xuXHRcdGlmIChpY29uKSByZXN1bHQucHVzaChpY29uKTtcblx0fSk7XG5cdHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuKiBEZWZhdWx0IFJlZHVuZGFuY3lDb25maWcgZm9yIEFQSSBjYWxsc1xuKi9cbmNvbnN0IGRlZmF1bHRDb25maWcgPSB7XG5cdHJlc291cmNlczogW10sXG5cdGluZGV4OiAwLFxuXHR0aW1lb3V0OiAyZTMsXG5cdHJvdGF0ZTogNzUwLFxuXHRyYW5kb206IGZhbHNlLFxuXHRkYXRhQWZ0ZXJUaW1lb3V0OiBmYWxzZVxufTtcblxuLyoqXG4qIFNlbmQgcXVlcnlcbiovXG5mdW5jdGlvbiBzZW5kUXVlcnkoY29uZmlnLCBwYXlsb2FkLCBxdWVyeSwgZG9uZSkge1xuXHRjb25zdCByZXNvdXJjZXNDb3VudCA9IGNvbmZpZy5yZXNvdXJjZXMubGVuZ3RoO1xuXHRjb25zdCBzdGFydEluZGV4ID0gY29uZmlnLnJhbmRvbSA/IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIHJlc291cmNlc0NvdW50KSA6IGNvbmZpZy5pbmRleDtcblx0bGV0IHJlc291cmNlcztcblx0aWYgKGNvbmZpZy5yYW5kb20pIHtcblx0XHRsZXQgbGlzdCA9IGNvbmZpZy5yZXNvdXJjZXMuc2xpY2UoMCk7XG5cdFx0cmVzb3VyY2VzID0gW107XG5cdFx0d2hpbGUgKGxpc3QubGVuZ3RoID4gMSkge1xuXHRcdFx0Y29uc3QgbmV4dEluZGV4ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogbGlzdC5sZW5ndGgpO1xuXHRcdFx0cmVzb3VyY2VzLnB1c2gobGlzdFtuZXh0SW5kZXhdKTtcblx0XHRcdGxpc3QgPSBsaXN0LnNsaWNlKDAsIG5leHRJbmRleCkuY29uY2F0KGxpc3Quc2xpY2UobmV4dEluZGV4ICsgMSkpO1xuXHRcdH1cblx0XHRyZXNvdXJjZXMgPSByZXNvdXJjZXMuY29uY2F0KGxpc3QpO1xuXHR9IGVsc2UgcmVzb3VyY2VzID0gY29uZmlnLnJlc291cmNlcy5zbGljZShzdGFydEluZGV4KS5jb25jYXQoY29uZmlnLnJlc291cmNlcy5zbGljZSgwLCBzdGFydEluZGV4KSk7XG5cdGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG5cdGxldCBzdGF0dXMgPSBcInBlbmRpbmdcIjtcblx0bGV0IHF1ZXJpZXNTZW50ID0gMDtcblx0bGV0IGxhc3RFcnJvcjtcblx0bGV0IHRpbWVyID0gbnVsbDtcblx0bGV0IHF1ZXVlID0gW107XG5cdGxldCBkb25lQ2FsbGJhY2tzID0gW107XG5cdGlmICh0eXBlb2YgZG9uZSA9PT0gXCJmdW5jdGlvblwiKSBkb25lQ2FsbGJhY2tzLnB1c2goZG9uZSk7XG5cdC8qKlxuXHQqIFJlc2V0IHRpbWVyXG5cdCovXG5cdGZ1bmN0aW9uIHJlc2V0VGltZXIoKSB7XG5cdFx0aWYgKHRpbWVyKSB7XG5cdFx0XHRjbGVhclRpbWVvdXQodGltZXIpO1xuXHRcdFx0dGltZXIgPSBudWxsO1xuXHRcdH1cblx0fVxuXHQvKipcblx0KiBBYm9ydCBldmVyeXRoaW5nXG5cdCovXG5cdGZ1bmN0aW9uIGFib3J0KCkge1xuXHRcdGlmIChzdGF0dXMgPT09IFwicGVuZGluZ1wiKSBzdGF0dXMgPSBcImFib3J0ZWRcIjtcblx0XHRyZXNldFRpbWVyKCk7XG5cdFx0cXVldWUuZm9yRWFjaCgoaXRlbSkgPT4ge1xuXHRcdFx0aWYgKGl0ZW0uc3RhdHVzID09PSBcInBlbmRpbmdcIikgaXRlbS5zdGF0dXMgPSBcImFib3J0ZWRcIjtcblx0XHR9KTtcblx0XHRxdWV1ZSA9IFtdO1xuXHR9XG5cdC8qKlxuXHQqIEFkZCAvIHJlcGxhY2UgY2FsbGJhY2sgdG8gY2FsbCB3aGVuIGV4ZWN1dGlvbiBpcyBjb21wbGV0ZS5cblx0KiBUaGlzIGNhbiBiZSB1c2VkIHRvIGFib3J0IHBlbmRpbmcgcXVlcnkgaW1wbGVtZW50YXRpb25zIHdoZW4gcXVlcnkgaXMgY29tcGxldGUgb3IgYWJvcnRlZC5cblx0Ki9cblx0ZnVuY3Rpb24gc3Vic2NyaWJlKGNhbGxiYWNrLCBvdmVyd3JpdGUpIHtcblx0XHRpZiAob3ZlcndyaXRlKSBkb25lQ2FsbGJhY2tzID0gW107XG5cdFx0aWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gXCJmdW5jdGlvblwiKSBkb25lQ2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuXHR9XG5cdC8qKlxuXHQqIEdldCBxdWVyeSBzdGF0dXNcblx0Ki9cblx0ZnVuY3Rpb24gZ2V0UXVlcnlTdGF0dXMoKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHN0YXJ0VGltZSxcblx0XHRcdHBheWxvYWQsXG5cdFx0XHRzdGF0dXMsXG5cdFx0XHRxdWVyaWVzU2VudCxcblx0XHRcdHF1ZXJpZXNQZW5kaW5nOiBxdWV1ZS5sZW5ndGgsXG5cdFx0XHRzdWJzY3JpYmUsXG5cdFx0XHRhYm9ydFxuXHRcdH07XG5cdH1cblx0LyoqXG5cdCogRmFpbCBxdWVyeVxuXHQqL1xuXHRmdW5jdGlvbiBmYWlsUXVlcnkoKSB7XG5cdFx0c3RhdHVzID0gXCJmYWlsZWRcIjtcblx0XHRkb25lQ2FsbGJhY2tzLmZvckVhY2goKGNhbGxiYWNrKSA9PiB7XG5cdFx0XHRjYWxsYmFjayh2b2lkIDAsIGxhc3RFcnJvcik7XG5cdFx0fSk7XG5cdH1cblx0LyoqXG5cdCogQ2xlYXIgcXVldWVcblx0Ki9cblx0ZnVuY3Rpb24gY2xlYXJRdWV1ZSgpIHtcblx0XHRxdWV1ZS5mb3JFYWNoKChpdGVtKSA9PiB7XG5cdFx0XHRpZiAoaXRlbS5zdGF0dXMgPT09IFwicGVuZGluZ1wiKSBpdGVtLnN0YXR1cyA9IFwiYWJvcnRlZFwiO1xuXHRcdH0pO1xuXHRcdHF1ZXVlID0gW107XG5cdH1cblx0LyoqXG5cdCogR290IHJlc3BvbnNlIGZyb20gbW9kdWxlXG5cdCovXG5cdGZ1bmN0aW9uIG1vZHVsZVJlc3BvbnNlKGl0ZW0sIHJlc3BvbnNlLCBkYXRhKSB7XG5cdFx0Y29uc3QgaXNFcnJvciA9IHJlc3BvbnNlICE9PSBcInN1Y2Nlc3NcIjtcblx0XHRxdWV1ZSA9IHF1ZXVlLmZpbHRlcigocXVldWVkKSA9PiBxdWV1ZWQgIT09IGl0ZW0pO1xuXHRcdHN3aXRjaCAoc3RhdHVzKSB7XG5cdFx0XHRjYXNlIFwicGVuZGluZ1wiOiBicmVhaztcblx0XHRcdGNhc2UgXCJmYWlsZWRcIjpcblx0XHRcdFx0aWYgKGlzRXJyb3IgfHwgIWNvbmZpZy5kYXRhQWZ0ZXJUaW1lb3V0KSByZXR1cm47XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0ZGVmYXVsdDogcmV0dXJuO1xuXHRcdH1cblx0XHRpZiAocmVzcG9uc2UgPT09IFwiYWJvcnRcIikge1xuXHRcdFx0bGFzdEVycm9yID0gZGF0YTtcblx0XHRcdGZhaWxRdWVyeSgpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRpZiAoaXNFcnJvcikge1xuXHRcdFx0bGFzdEVycm9yID0gZGF0YTtcblx0XHRcdGlmICghcXVldWUubGVuZ3RoKSBpZiAoIXJlc291cmNlcy5sZW5ndGgpIGZhaWxRdWVyeSgpO1xuXHRcdFx0ZWxzZSBleGVjTmV4dCgpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRyZXNldFRpbWVyKCk7XG5cdFx0Y2xlYXJRdWV1ZSgpO1xuXHRcdGlmICghY29uZmlnLnJhbmRvbSkge1xuXHRcdFx0Y29uc3QgaW5kZXggPSBjb25maWcucmVzb3VyY2VzLmluZGV4T2YoaXRlbS5yZXNvdXJjZSk7XG5cdFx0XHRpZiAoaW5kZXggIT09IC0xICYmIGluZGV4ICE9PSBjb25maWcuaW5kZXgpIGNvbmZpZy5pbmRleCA9IGluZGV4O1xuXHRcdH1cblx0XHRzdGF0dXMgPSBcImNvbXBsZXRlZFwiO1xuXHRcdGRvbmVDYWxsYmFja3MuZm9yRWFjaCgoY2FsbGJhY2spID0+IHtcblx0XHRcdGNhbGxiYWNrKGRhdGEpO1xuXHRcdH0pO1xuXHR9XG5cdC8qKlxuXHQqIEV4ZWN1dGUgbmV4dCBxdWVyeVxuXHQqL1xuXHRmdW5jdGlvbiBleGVjTmV4dCgpIHtcblx0XHRpZiAoc3RhdHVzICE9PSBcInBlbmRpbmdcIikgcmV0dXJuO1xuXHRcdHJlc2V0VGltZXIoKTtcblx0XHRjb25zdCByZXNvdXJjZSA9IHJlc291cmNlcy5zaGlmdCgpO1xuXHRcdGlmIChyZXNvdXJjZSA9PT0gdm9pZCAwKSB7XG5cdFx0XHRpZiAocXVldWUubGVuZ3RoKSB7XG5cdFx0XHRcdHRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG5cdFx0XHRcdFx0cmVzZXRUaW1lcigpO1xuXHRcdFx0XHRcdGlmIChzdGF0dXMgPT09IFwicGVuZGluZ1wiKSB7XG5cdFx0XHRcdFx0XHRjbGVhclF1ZXVlKCk7XG5cdFx0XHRcdFx0XHRmYWlsUXVlcnkoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sIGNvbmZpZy50aW1lb3V0KTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0ZmFpbFF1ZXJ5KCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGNvbnN0IGl0ZW0gPSB7XG5cdFx0XHRzdGF0dXM6IFwicGVuZGluZ1wiLFxuXHRcdFx0cmVzb3VyY2UsXG5cdFx0XHRjYWxsYmFjazogKHN0YXR1cyQxLCBkYXRhKSA9PiB7XG5cdFx0XHRcdG1vZHVsZVJlc3BvbnNlKGl0ZW0sIHN0YXR1cyQxLCBkYXRhKTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdHF1ZXVlLnB1c2goaXRlbSk7XG5cdFx0cXVlcmllc1NlbnQrKztcblx0XHR0aW1lciA9IHNldFRpbWVvdXQoZXhlY05leHQsIGNvbmZpZy5yb3RhdGUpO1xuXHRcdHF1ZXJ5KHJlc291cmNlLCBwYXlsb2FkLCBpdGVtLmNhbGxiYWNrKTtcblx0fVxuXHRzZXRUaW1lb3V0KGV4ZWNOZXh0KTtcblx0cmV0dXJuIGdldFF1ZXJ5U3RhdHVzO1xufVxuXG4vKipcbiogUmVkdW5kYW5jeSBpbnN0YW5jZVxuKi9cbmZ1bmN0aW9uIGluaXRSZWR1bmRhbmN5KGNmZykge1xuXHRjb25zdCBjb25maWcgPSB7XG5cdFx0Li4uZGVmYXVsdENvbmZpZyxcblx0XHQuLi5jZmdcblx0fTtcblx0bGV0IHF1ZXJpZXMgPSBbXTtcblx0LyoqXG5cdCogUmVtb3ZlIGFib3J0ZWQgYW5kIGNvbXBsZXRlZCBxdWVyaWVzXG5cdCovXG5cdGZ1bmN0aW9uIGNsZWFudXAoKSB7XG5cdFx0cXVlcmllcyA9IHF1ZXJpZXMuZmlsdGVyKChpdGVtKSA9PiBpdGVtKCkuc3RhdHVzID09PSBcInBlbmRpbmdcIik7XG5cdH1cblx0LyoqXG5cdCogU2VuZCBxdWVyeVxuXHQqL1xuXHRmdW5jdGlvbiBxdWVyeShwYXlsb2FkLCBxdWVyeUNhbGxiYWNrLCBkb25lQ2FsbGJhY2spIHtcblx0XHRjb25zdCBxdWVyeSQxID0gc2VuZFF1ZXJ5KGNvbmZpZywgcGF5bG9hZCwgcXVlcnlDYWxsYmFjaywgKGRhdGEsIGVycm9yKSA9PiB7XG5cdFx0XHRjbGVhbnVwKCk7XG5cdFx0XHRpZiAoZG9uZUNhbGxiYWNrKSBkb25lQ2FsbGJhY2soZGF0YSwgZXJyb3IpO1xuXHRcdH0pO1xuXHRcdHF1ZXJpZXMucHVzaChxdWVyeSQxKTtcblx0XHRyZXR1cm4gcXVlcnkkMTtcblx0fVxuXHQvKipcblx0KiBGaW5kIGluc3RhbmNlXG5cdCovXG5cdGZ1bmN0aW9uIGZpbmQoY2FsbGJhY2spIHtcblx0XHRyZXR1cm4gcXVlcmllcy5maW5kKCh2YWx1ZSkgPT4ge1xuXHRcdFx0cmV0dXJuIGNhbGxiYWNrKHZhbHVlKTtcblx0XHR9KSB8fCBudWxsO1xuXHR9XG5cdGNvbnN0IGluc3RhbmNlID0ge1xuXHRcdHF1ZXJ5LFxuXHRcdGZpbmQsXG5cdFx0c2V0SW5kZXg6IChpbmRleCkgPT4ge1xuXHRcdFx0Y29uZmlnLmluZGV4ID0gaW5kZXg7XG5cdFx0fSxcblx0XHRnZXRJbmRleDogKCkgPT4gY29uZmlnLmluZGV4LFxuXHRcdGNsZWFudXBcblx0fTtcblx0cmV0dXJuIGluc3RhbmNlO1xufVxuXG5mdW5jdGlvbiBlbXB0eUNhbGxiYWNrJDEoKSB7fVxuY29uc3QgcmVkdW5kYW5jeUNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbi8qKlxuKiBHZXQgUmVkdW5kYW5jeSBpbnN0YW5jZSBmb3IgcHJvdmlkZXJcbiovXG5mdW5jdGlvbiBnZXRSZWR1bmRhbmN5Q2FjaGUocHJvdmlkZXIpIHtcblx0aWYgKCFyZWR1bmRhbmN5Q2FjaGVbcHJvdmlkZXJdKSB7XG5cdFx0Y29uc3QgY29uZmlnID0gZ2V0QVBJQ29uZmlnKHByb3ZpZGVyKTtcblx0XHRpZiAoIWNvbmZpZykgcmV0dXJuO1xuXHRcdGNvbnN0IHJlZHVuZGFuY3kgPSBpbml0UmVkdW5kYW5jeShjb25maWcpO1xuXHRcdGNvbnN0IGNhY2hlZFJldW5kYW5jeSA9IHtcblx0XHRcdGNvbmZpZyxcblx0XHRcdHJlZHVuZGFuY3lcblx0XHR9O1xuXHRcdHJlZHVuZGFuY3lDYWNoZVtwcm92aWRlcl0gPSBjYWNoZWRSZXVuZGFuY3k7XG5cdH1cblx0cmV0dXJuIHJlZHVuZGFuY3lDYWNoZVtwcm92aWRlcl07XG59XG4vKipcbiogU2VuZCBBUEkgcXVlcnlcbiovXG5mdW5jdGlvbiBzZW5kQVBJUXVlcnkodGFyZ2V0LCBxdWVyeSwgY2FsbGJhY2spIHtcblx0bGV0IHJlZHVuZGFuY3k7XG5cdGxldCBzZW5kO1xuXHRpZiAodHlwZW9mIHRhcmdldCA9PT0gXCJzdHJpbmdcIikge1xuXHRcdGNvbnN0IGFwaSA9IGdldEFQSU1vZHVsZSh0YXJnZXQpO1xuXHRcdGlmICghYXBpKSB7XG5cdFx0XHRjYWxsYmFjayh2b2lkIDAsIDQyNCk7XG5cdFx0XHRyZXR1cm4gZW1wdHlDYWxsYmFjayQxO1xuXHRcdH1cblx0XHRzZW5kID0gYXBpLnNlbmQ7XG5cdFx0Y29uc3QgY2FjaGVkID0gZ2V0UmVkdW5kYW5jeUNhY2hlKHRhcmdldCk7XG5cdFx0aWYgKGNhY2hlZCkgcmVkdW5kYW5jeSA9IGNhY2hlZC5yZWR1bmRhbmN5O1xuXHR9IGVsc2Uge1xuXHRcdGNvbnN0IGNvbmZpZyA9IGNyZWF0ZUFQSUNvbmZpZyh0YXJnZXQpO1xuXHRcdGlmIChjb25maWcpIHtcblx0XHRcdHJlZHVuZGFuY3kgPSBpbml0UmVkdW5kYW5jeShjb25maWcpO1xuXHRcdFx0Y29uc3QgbW9kdWxlS2V5ID0gdGFyZ2V0LnJlc291cmNlcyA/IHRhcmdldC5yZXNvdXJjZXNbMF0gOiBcIlwiO1xuXHRcdFx0Y29uc3QgYXBpID0gZ2V0QVBJTW9kdWxlKG1vZHVsZUtleSk7XG5cdFx0XHRpZiAoYXBpKSBzZW5kID0gYXBpLnNlbmQ7XG5cdFx0fVxuXHR9XG5cdGlmICghcmVkdW5kYW5jeSB8fCAhc2VuZCkge1xuXHRcdGNhbGxiYWNrKHZvaWQgMCwgNDI0KTtcblx0XHRyZXR1cm4gZW1wdHlDYWxsYmFjayQxO1xuXHR9XG5cdHJldHVybiByZWR1bmRhbmN5LnF1ZXJ5KHF1ZXJ5LCBzZW5kLCBjYWxsYmFjaykoKS5hYm9ydDtcbn1cblxuZnVuY3Rpb24gZW1wdHlDYWxsYmFjaygpIHt9XG4vKipcbiogRnVuY3Rpb24gY2FsbGVkIHdoZW4gbmV3IGljb25zIGhhdmUgYmVlbiBsb2FkZWRcbiovXG5mdW5jdGlvbiBsb2FkZWROZXdJY29ucyhzdG9yYWdlKSB7XG5cdGlmICghc3RvcmFnZS5pY29uc0xvYWRlckZsYWcpIHtcblx0XHRzdG9yYWdlLmljb25zTG9hZGVyRmxhZyA9IHRydWU7XG5cdFx0c2V0VGltZW91dCgoKSA9PiB7XG5cdFx0XHRzdG9yYWdlLmljb25zTG9hZGVyRmxhZyA9IGZhbHNlO1xuXHRcdFx0dXBkYXRlQ2FsbGJhY2tzKHN0b3JhZ2UpO1xuXHRcdH0pO1xuXHR9XG59XG4vKipcbiogQ2hlY2sgaWNvbiBuYW1lcyBmb3IgQVBJXG4qL1xuZnVuY3Rpb24gY2hlY2tJY29uTmFtZXNGb3JBUEkoaWNvbnMpIHtcblx0Y29uc3QgdmFsaWQgPSBbXTtcblx0Y29uc3QgaW52YWxpZCA9IFtdO1xuXHRpY29ucy5mb3JFYWNoKChuYW1lKSA9PiB7XG5cdFx0KG5hbWUubWF0Y2gobWF0Y2hJY29uTmFtZSkgPyB2YWxpZCA6IGludmFsaWQpLnB1c2gobmFtZSk7XG5cdH0pO1xuXHRyZXR1cm4ge1xuXHRcdHZhbGlkLFxuXHRcdGludmFsaWRcblx0fTtcbn1cbi8qKlxuKiBQYXJzZSBsb2FkZXIgcmVzcG9uc2VcbiovXG5mdW5jdGlvbiBwYXJzZUxvYWRlclJlc3BvbnNlKHN0b3JhZ2UsIGljb25zLCBkYXRhKSB7XG5cdGZ1bmN0aW9uIGNoZWNrTWlzc2luZygpIHtcblx0XHRjb25zdCBwZW5kaW5nID0gc3RvcmFnZS5wZW5kaW5nSWNvbnM7XG5cdFx0aWNvbnMuZm9yRWFjaCgobmFtZSkgPT4ge1xuXHRcdFx0aWYgKHBlbmRpbmcpIHBlbmRpbmcuZGVsZXRlKG5hbWUpO1xuXHRcdFx0aWYgKCFzdG9yYWdlLmljb25zW25hbWVdKSBzdG9yYWdlLm1pc3NpbmcuYWRkKG5hbWUpO1xuXHRcdH0pO1xuXHR9XG5cdGlmIChkYXRhICYmIHR5cGVvZiBkYXRhID09PSBcIm9iamVjdFwiKSB0cnkge1xuXHRcdGNvbnN0IHBhcnNlZCA9IGFkZEljb25TZXQoc3RvcmFnZSwgZGF0YSk7XG5cdFx0aWYgKCFwYXJzZWQubGVuZ3RoKSB7XG5cdFx0XHRjaGVja01pc3NpbmcoKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdH0gY2F0Y2ggKGVycikge1xuXHRcdGNvbnNvbGUuZXJyb3IoZXJyKTtcblx0fVxuXHRjaGVja01pc3NpbmcoKTtcblx0bG9hZGVkTmV3SWNvbnMoc3RvcmFnZSk7XG59XG4vKipcbiogSGFuZGxlIHJlc3BvbnNlIHRoYXQgY2FuIGJlIGFzeW5jXG4qL1xuZnVuY3Rpb24gcGFyc2VQb3NzaWJseUFzeW5jUmVzcG9uc2UocmVzcG9uc2UsIGNhbGxiYWNrKSB7XG5cdGlmIChyZXNwb25zZSBpbnN0YW5jZW9mIFByb21pc2UpIHJlc3BvbnNlLnRoZW4oKGRhdGEpID0+IHtcblx0XHRjYWxsYmFjayhkYXRhKTtcblx0fSkuY2F0Y2goKCkgPT4ge1xuXHRcdGNhbGxiYWNrKG51bGwpO1xuXHR9KTtcblx0ZWxzZSBjYWxsYmFjayhyZXNwb25zZSk7XG59XG4vKipcbiogTG9hZCBpY29uc1xuKi9cbmZ1bmN0aW9uIGxvYWROZXdJY29ucyhzdG9yYWdlLCBpY29ucykge1xuXHRpZiAoIXN0b3JhZ2UuaWNvbnNUb0xvYWQpIHN0b3JhZ2UuaWNvbnNUb0xvYWQgPSBpY29ucztcblx0ZWxzZSBzdG9yYWdlLmljb25zVG9Mb2FkID0gc3RvcmFnZS5pY29uc1RvTG9hZC5jb25jYXQoaWNvbnMpLnNvcnQoKTtcblx0aWYgKCFzdG9yYWdlLmljb25zUXVldWVGbGFnKSB7XG5cdFx0c3RvcmFnZS5pY29uc1F1ZXVlRmxhZyA9IHRydWU7XG5cdFx0c2V0VGltZW91dCgoKSA9PiB7XG5cdFx0XHRzdG9yYWdlLmljb25zUXVldWVGbGFnID0gZmFsc2U7XG5cdFx0XHRjb25zdCB7IHByb3ZpZGVyLCBwcmVmaXggfSA9IHN0b3JhZ2U7XG5cdFx0XHRjb25zdCBpY29ucyQxID0gc3RvcmFnZS5pY29uc1RvTG9hZDtcblx0XHRcdGRlbGV0ZSBzdG9yYWdlLmljb25zVG9Mb2FkO1xuXHRcdFx0aWYgKCFpY29ucyQxIHx8ICFpY29ucyQxLmxlbmd0aCkgcmV0dXJuO1xuXHRcdFx0Y29uc3QgY3VzdG9tSWNvbkxvYWRlciA9IHN0b3JhZ2UubG9hZEljb247XG5cdFx0XHRpZiAoc3RvcmFnZS5sb2FkSWNvbnMgJiYgKGljb25zJDEubGVuZ3RoID4gMSB8fCAhY3VzdG9tSWNvbkxvYWRlcikpIHtcblx0XHRcdFx0cGFyc2VQb3NzaWJseUFzeW5jUmVzcG9uc2Uoc3RvcmFnZS5sb2FkSWNvbnMoaWNvbnMkMSwgcHJlZml4LCBwcm92aWRlciksIChkYXRhKSA9PiB7XG5cdFx0XHRcdFx0cGFyc2VMb2FkZXJSZXNwb25zZShzdG9yYWdlLCBpY29ucyQxLCBkYXRhKTtcblx0XHRcdFx0fSk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdGlmIChjdXN0b21JY29uTG9hZGVyKSB7XG5cdFx0XHRcdGljb25zJDEuZm9yRWFjaCgobmFtZSkgPT4ge1xuXHRcdFx0XHRcdGNvbnN0IHJlc3BvbnNlID0gY3VzdG9tSWNvbkxvYWRlcihuYW1lLCBwcmVmaXgsIHByb3ZpZGVyKTtcblx0XHRcdFx0XHRwYXJzZVBvc3NpYmx5QXN5bmNSZXNwb25zZShyZXNwb25zZSwgKGRhdGEpID0+IHtcblx0XHRcdFx0XHRcdGNvbnN0IGljb25TZXQgPSBkYXRhID8ge1xuXHRcdFx0XHRcdFx0XHRwcmVmaXgsXG5cdFx0XHRcdFx0XHRcdGljb25zOiB7IFtuYW1lXTogZGF0YSB9XG5cdFx0XHRcdFx0XHR9IDogbnVsbDtcblx0XHRcdFx0XHRcdHBhcnNlTG9hZGVyUmVzcG9uc2Uoc3RvcmFnZSwgW25hbWVdLCBpY29uU2V0KTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fSk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdGNvbnN0IHsgdmFsaWQsIGludmFsaWQgfSA9IGNoZWNrSWNvbk5hbWVzRm9yQVBJKGljb25zJDEpO1xuXHRcdFx0aWYgKGludmFsaWQubGVuZ3RoKSBwYXJzZUxvYWRlclJlc3BvbnNlKHN0b3JhZ2UsIGludmFsaWQsIG51bGwpO1xuXHRcdFx0aWYgKCF2YWxpZC5sZW5ndGgpIHJldHVybjtcblx0XHRcdGNvbnN0IGFwaSA9IHByZWZpeC5tYXRjaChtYXRjaEljb25OYW1lKSA/IGdldEFQSU1vZHVsZShwcm92aWRlcikgOiBudWxsO1xuXHRcdFx0aWYgKCFhcGkpIHtcblx0XHRcdFx0cGFyc2VMb2FkZXJSZXNwb25zZShzdG9yYWdlLCB2YWxpZCwgbnVsbCk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdGNvbnN0IHBhcmFtcyA9IGFwaS5wcmVwYXJlKHByb3ZpZGVyLCBwcmVmaXgsIHZhbGlkKTtcblx0XHRcdHBhcmFtcy5mb3JFYWNoKChpdGVtKSA9PiB7XG5cdFx0XHRcdHNlbmRBUElRdWVyeShwcm92aWRlciwgaXRlbSwgKGRhdGEpID0+IHtcblx0XHRcdFx0XHRwYXJzZUxvYWRlclJlc3BvbnNlKHN0b3JhZ2UsIGl0ZW0uaWNvbnMsIGRhdGEpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH0pO1xuXHRcdH0pO1xuXHR9XG59XG4vKipcbiogTG9hZCBpY29uc1xuKi9cbmNvbnN0IGxvYWRJY29ucyA9IChpY29ucywgY2FsbGJhY2spID0+IHtcblx0Y29uc3QgY2xlYW5lZEljb25zID0gbGlzdFRvSWNvbnMoaWNvbnMsIHRydWUsIGFsbG93U2ltcGxlTmFtZXMoKSk7XG5cdGNvbnN0IHNvcnRlZEljb25zID0gc29ydEljb25zKGNsZWFuZWRJY29ucyk7XG5cdGlmICghc29ydGVkSWNvbnMucGVuZGluZy5sZW5ndGgpIHtcblx0XHRsZXQgY2FsbENhbGxiYWNrID0gdHJ1ZTtcblx0XHRpZiAoY2FsbGJhY2spIHNldFRpbWVvdXQoKCkgPT4ge1xuXHRcdFx0aWYgKGNhbGxDYWxsYmFjaykgY2FsbGJhY2soc29ydGVkSWNvbnMubG9hZGVkLCBzb3J0ZWRJY29ucy5taXNzaW5nLCBzb3J0ZWRJY29ucy5wZW5kaW5nLCBlbXB0eUNhbGxiYWNrKTtcblx0XHR9KTtcblx0XHRyZXR1cm4gKCkgPT4ge1xuXHRcdFx0Y2FsbENhbGxiYWNrID0gZmFsc2U7XG5cdFx0fTtcblx0fVxuXHRjb25zdCBuZXdJY29ucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cdGNvbnN0IHNvdXJjZXMgPSBbXTtcblx0bGV0IGxhc3RQcm92aWRlciwgbGFzdFByZWZpeDtcblx0c29ydGVkSWNvbnMucGVuZGluZy5mb3JFYWNoKChpY29uKSA9PiB7XG5cdFx0Y29uc3QgeyBwcm92aWRlciwgcHJlZml4IH0gPSBpY29uO1xuXHRcdGlmIChwcmVmaXggPT09IGxhc3RQcmVmaXggJiYgcHJvdmlkZXIgPT09IGxhc3RQcm92aWRlcikgcmV0dXJuO1xuXHRcdGxhc3RQcm92aWRlciA9IHByb3ZpZGVyO1xuXHRcdGxhc3RQcmVmaXggPSBwcmVmaXg7XG5cdFx0c291cmNlcy5wdXNoKGdldFN0b3JhZ2UocHJvdmlkZXIsIHByZWZpeCkpO1xuXHRcdGNvbnN0IHByb3ZpZGVyTmV3SWNvbnMgPSBuZXdJY29uc1twcm92aWRlcl0gfHwgKG5ld0ljb25zW3Byb3ZpZGVyXSA9IE9iamVjdC5jcmVhdGUobnVsbCkpO1xuXHRcdGlmICghcHJvdmlkZXJOZXdJY29uc1twcmVmaXhdKSBwcm92aWRlck5ld0ljb25zW3ByZWZpeF0gPSBbXTtcblx0fSk7XG5cdHNvcnRlZEljb25zLnBlbmRpbmcuZm9yRWFjaCgoaWNvbikgPT4ge1xuXHRcdGNvbnN0IHsgcHJvdmlkZXIsIHByZWZpeCwgbmFtZSB9ID0gaWNvbjtcblx0XHRjb25zdCBzdG9yYWdlID0gZ2V0U3RvcmFnZShwcm92aWRlciwgcHJlZml4KTtcblx0XHRjb25zdCBwZW5kaW5nUXVldWUgPSBzdG9yYWdlLnBlbmRpbmdJY29ucyB8fCAoc3RvcmFnZS5wZW5kaW5nSWNvbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpKTtcblx0XHRpZiAoIXBlbmRpbmdRdWV1ZS5oYXMobmFtZSkpIHtcblx0XHRcdHBlbmRpbmdRdWV1ZS5hZGQobmFtZSk7XG5cdFx0XHRuZXdJY29uc1twcm92aWRlcl1bcHJlZml4XS5wdXNoKG5hbWUpO1xuXHRcdH1cblx0fSk7XG5cdHNvdXJjZXMuZm9yRWFjaCgoc3RvcmFnZSkgPT4ge1xuXHRcdGNvbnN0IGxpc3QgPSBuZXdJY29uc1tzdG9yYWdlLnByb3ZpZGVyXVtzdG9yYWdlLnByZWZpeF07XG5cdFx0aWYgKGxpc3QubGVuZ3RoKSBsb2FkTmV3SWNvbnMoc3RvcmFnZSwgbGlzdCk7XG5cdH0pO1xuXHRyZXR1cm4gY2FsbGJhY2sgPyBzdG9yZUNhbGxiYWNrKGNhbGxiYWNrLCBzb3J0ZWRJY29ucywgc291cmNlcykgOiBlbXB0eUNhbGxiYWNrO1xufTtcbi8qKlxuKiBMb2FkIG9uZSBpY29uIHVzaW5nIFByb21pc2VcbiovXG5jb25zdCBsb2FkSWNvbiA9IChpY29uKSA9PiB7XG5cdHJldHVybiBuZXcgUHJvbWlzZSgoZnVsZmlsbCwgcmVqZWN0KSA9PiB7XG5cdFx0Y29uc3QgaWNvbk9iaiA9IHR5cGVvZiBpY29uID09PSBcInN0cmluZ1wiID8gc3RyaW5nVG9JY29uKGljb24sIHRydWUpIDogaWNvbjtcblx0XHRpZiAoIWljb25PYmopIHtcblx0XHRcdHJlamVjdChpY29uKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0bG9hZEljb25zKFtpY29uT2JqIHx8IGljb25dLCAobG9hZGVkKSA9PiB7XG5cdFx0XHRpZiAobG9hZGVkLmxlbmd0aCAmJiBpY29uT2JqKSB7XG5cdFx0XHRcdGNvbnN0IGRhdGEgPSBnZXRJY29uRGF0YShpY29uT2JqKTtcblx0XHRcdFx0aWYgKGRhdGEpIHtcblx0XHRcdFx0XHRmdWxmaWxsKHtcblx0XHRcdFx0XHRcdC4uLmRlZmF1bHRJY29uUHJvcHMsXG5cdFx0XHRcdFx0XHQuLi5kYXRhXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZWplY3QoaWNvbik7XG5cdFx0fSk7XG5cdH0pO1xufTtcblxuLyoqXG4qIFNldCBjdXN0b20gbG9hZGVyIGZvciBtdWx0aXBsZSBpY29uc1xuKi9cbmZ1bmN0aW9uIHNldEN1c3RvbUljb25zTG9hZGVyKGxvYWRlciwgcHJlZml4LCBwcm92aWRlcikge1xuXHRnZXRTdG9yYWdlKHByb3ZpZGVyIHx8IFwiXCIsIHByZWZpeCkubG9hZEljb25zID0gbG9hZGVyO1xufVxuLyoqXG4qIFNldCBjdXN0b20gbG9hZGVyIGZvciBvbmUgaWNvblxuKi9cbmZ1bmN0aW9uIHNldEN1c3RvbUljb25Mb2FkZXIobG9hZGVyLCBwcmVmaXgsIHByb3ZpZGVyKSB7XG5cdGdldFN0b3JhZ2UocHJvdmlkZXIgfHwgXCJcIiwgcHJlZml4KS5sb2FkSWNvbiA9IGxvYWRlcjtcbn1cblxuLyoqXG4qIENvbnZlcnQgSWNvbmlmeUljb25DdXN0b21pc2F0aW9ucyB0byBGdWxsSWNvbkN1c3RvbWlzYXRpb25zLCBjaGVja2luZyB2YWx1ZSB0eXBlc1xuKi9cbmZ1bmN0aW9uIG1lcmdlQ3VzdG9taXNhdGlvbnMoZGVmYXVsdHMsIGl0ZW0pIHtcblx0Y29uc3QgcmVzdWx0ID0geyAuLi5kZWZhdWx0cyB9O1xuXHRmb3IgKGNvbnN0IGtleSBpbiBpdGVtKSB7XG5cdFx0Y29uc3QgdmFsdWUgPSBpdGVtW2tleV07XG5cdFx0Y29uc3QgdmFsdWVUeXBlID0gdHlwZW9mIHZhbHVlO1xuXHRcdGlmIChrZXkgaW4gZGVmYXVsdEljb25TaXplQ3VzdG9taXNhdGlvbnMpIHtcblx0XHRcdGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSAmJiAodmFsdWVUeXBlID09PSBcInN0cmluZ1wiIHx8IHZhbHVlVHlwZSA9PT0gXCJudW1iZXJcIikpIHJlc3VsdFtrZXldID0gdmFsdWU7XG5cdFx0fSBlbHNlIGlmICh2YWx1ZVR5cGUgPT09IHR5cGVvZiByZXN1bHRba2V5XSkgcmVzdWx0W2tleV0gPSBrZXkgPT09IFwicm90YXRlXCIgPyB2YWx1ZSAlIDQgOiB2YWx1ZTtcblx0fVxuXHRyZXR1cm4gcmVzdWx0O1xufVxuXG5jb25zdCBzZXBhcmF0b3IgPSAvW1xccyxdKy87XG4vKipcbiogQXBwbHkgXCJmbGlwXCIgc3RyaW5nIHRvIGljb24gY3VzdG9taXNhdGlvbnNcbiovXG5mdW5jdGlvbiBmbGlwRnJvbVN0cmluZyhjdXN0b20sIGZsaXApIHtcblx0ZmxpcC5zcGxpdChzZXBhcmF0b3IpLmZvckVhY2goKHN0cikgPT4ge1xuXHRcdGNvbnN0IHZhbHVlID0gc3RyLnRyaW0oKTtcblx0XHRzd2l0Y2ggKHZhbHVlKSB7XG5cdFx0XHRjYXNlIFwiaG9yaXpvbnRhbFwiOlxuXHRcdFx0XHRjdXN0b20uaEZsaXAgPSB0cnVlO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgXCJ2ZXJ0aWNhbFwiOlxuXHRcdFx0XHRjdXN0b20udkZsaXAgPSB0cnVlO1xuXHRcdFx0XHRicmVhaztcblx0XHR9XG5cdH0pO1xufVxuXG4vKipcbiogR2V0IHJvdGF0aW9uIHZhbHVlXG4qL1xuZnVuY3Rpb24gcm90YXRlRnJvbVN0cmluZyh2YWx1ZSwgZGVmYXVsdFZhbHVlID0gMCkge1xuXHRjb25zdCB1bml0cyA9IHZhbHVlLnJlcGxhY2UoL14tP1swLTkuXSovLCBcIlwiKTtcblx0ZnVuY3Rpb24gY2xlYW51cCh2YWx1ZSQxKSB7XG5cdFx0d2hpbGUgKHZhbHVlJDEgPCAwKSB2YWx1ZSQxICs9IDQ7XG5cdFx0cmV0dXJuIHZhbHVlJDEgJSA0O1xuXHR9XG5cdGlmICh1bml0cyA9PT0gXCJcIikge1xuXHRcdGNvbnN0IG51bSA9IHBhcnNlSW50KHZhbHVlKTtcblx0XHRyZXR1cm4gaXNOYU4obnVtKSA/IDAgOiBjbGVhbnVwKG51bSk7XG5cdH0gZWxzZSBpZiAodW5pdHMgIT09IHZhbHVlKSB7XG5cdFx0bGV0IHNwbGl0ID0gMDtcblx0XHRzd2l0Y2ggKHVuaXRzKSB7XG5cdFx0XHRjYXNlIFwiJVwiOlxuXHRcdFx0XHRzcGxpdCA9IDI1O1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgXCJkZWdcIjogc3BsaXQgPSA5MDtcblx0XHR9XG5cdFx0aWYgKHNwbGl0KSB7XG5cdFx0XHRsZXQgbnVtID0gcGFyc2VGbG9hdCh2YWx1ZS5zbGljZSgwLCB2YWx1ZS5sZW5ndGggLSB1bml0cy5sZW5ndGgpKTtcblx0XHRcdGlmIChpc05hTihudW0pKSByZXR1cm4gMDtcblx0XHRcdG51bSA9IG51bSAvIHNwbGl0O1xuXHRcdFx0cmV0dXJuIG51bSAlIDEgPT09IDAgPyBjbGVhbnVwKG51bSkgOiAwO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gZGVmYXVsdFZhbHVlO1xufVxuXG4vKipcbiogR2VuZXJhdGUgPHN2Zz5cbiovXG5mdW5jdGlvbiBpY29uVG9IVE1MKGJvZHksIGF0dHJpYnV0ZXMpIHtcblx0bGV0IHJlbmRlckF0dHJpYnNIVE1MID0gYm9keS5pbmRleE9mKFwieGxpbms6XCIpID09PSAtMSA/IFwiXCIgOiBcIiB4bWxuczp4bGluaz1cXFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1xcXCJcIjtcblx0Zm9yIChjb25zdCBhdHRyIGluIGF0dHJpYnV0ZXMpIHJlbmRlckF0dHJpYnNIVE1MICs9IFwiIFwiICsgYXR0ciArIFwiPVxcXCJcIiArIGF0dHJpYnV0ZXNbYXR0cl0gKyBcIlxcXCJcIjtcblx0cmV0dXJuIFwiPHN2ZyB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiXCIgKyByZW5kZXJBdHRyaWJzSFRNTCArIFwiPlwiICsgYm9keSArIFwiPC9zdmc+XCI7XG59XG5cbi8qKlxuKiBFbmNvZGUgU1ZHIGZvciB1c2UgaW4gdXJsKClcbipcbiogU2hvcnQgYWx0ZXJuYXRpdmUgdG8gZW5jb2RlVVJJQ29tcG9uZW50KCkgdGhhdCBlbmNvZGVzIG9ubHkgc3R1ZmYgdXNlZCBpbiBTVkcsIGdlbmVyYXRpbmdcbiogc21hbGxlciBjb2RlLlxuKi9cbmZ1bmN0aW9uIGVuY29kZVNWR2ZvclVSTChzdmcpIHtcblx0cmV0dXJuIHN2Zy5yZXBsYWNlKC9cIi9nLCBcIidcIikucmVwbGFjZSgvJS9nLCBcIiUyNVwiKS5yZXBsYWNlKC8jL2csIFwiJTIzXCIpLnJlcGxhY2UoLzwvZywgXCIlM0NcIikucmVwbGFjZSgvPi9nLCBcIiUzRVwiKS5yZXBsYWNlKC9cXHMrL2csIFwiIFwiKTtcbn1cbi8qKlxuKiBHZW5lcmF0ZSBkYXRhOiBVUkwgZnJvbSBTVkdcbiovXG5mdW5jdGlvbiBzdmdUb0RhdGEoc3ZnKSB7XG5cdHJldHVybiBcImRhdGE6aW1hZ2Uvc3ZnK3htbCxcIiArIGVuY29kZVNWR2ZvclVSTChzdmcpO1xufVxuLyoqXG4qIEdlbmVyYXRlIHVybCgpIGZyb20gU1ZHXG4qL1xuZnVuY3Rpb24gc3ZnVG9VUkwoc3ZnKSB7XG5cdHJldHVybiBcInVybChcXFwiXCIgKyBzdmdUb0RhdGEoc3ZnKSArIFwiXFxcIilcIjtcbn1cblxubGV0IHBvbGljeTtcbi8qKlxuKiBBdHRlbXB0IHRvIGNyZWF0ZSBwb2xpY3lcbiovXG5mdW5jdGlvbiBjcmVhdGVQb2xpY3koKSB7XG5cdHRyeSB7XG5cdFx0cG9saWN5ID0gd2luZG93LnRydXN0ZWRUeXBlcy5jcmVhdGVQb2xpY3koXCJpY29uaWZ5XCIsIHsgY3JlYXRlSFRNTDogKHMpID0+IHMgfSk7XG5cdH0gY2F0Y2ggKGVycikge1xuXHRcdHBvbGljeSA9IG51bGw7XG5cdH1cbn1cbi8qKlxuKiBDbGVhbiB1cCB2YWx1ZSBmb3IgaW5uZXJIVE1MIGFzc2lnbm1lbnRcbipcbiogVGhpcyBjb2RlIGRvZXNuJ3QgYWN0dWFsbHkgY2xlYW4gdXAgYW55dGhpbmcuXG4qIEl0IGlzIGludGVuZGVkIGJlIHVzZWQgd2l0aCBJY29uaWZ5IGljb24gZGF0YSwgd2hpY2ggaGFzIGFscmVhZHkgYmVlbiB2YWxpZGF0ZWRcbiovXG5mdW5jdGlvbiBjbGVhblVwSW5uZXJIVE1MKGh0bWwpIHtcblx0aWYgKHBvbGljeSA9PT0gdm9pZCAwKSBjcmVhdGVQb2xpY3koKTtcblx0cmV0dXJuIHBvbGljeSA/IHBvbGljeS5jcmVhdGVIVE1MKGh0bWwpIDogaHRtbDtcbn1cblxuY29uc3QgZGVmYXVsdEV4dGVuZGVkSWNvbkN1c3RvbWlzYXRpb25zID0ge1xuICAgIC4uLmRlZmF1bHRJY29uQ3VzdG9taXNhdGlvbnMsXG4gICAgaW5saW5lOiBmYWxzZSxcbn07XG5cbi8qKlxuICogRGVmYXVsdCBTVkcgYXR0cmlidXRlc1xuICovXG5jb25zdCBzdmdEZWZhdWx0cyA9IHtcbiAgICAneG1sbnMnOiAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLFxuICAgICd4bWxuc1hsaW5rJzogJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnLFxuICAgICdhcmlhLWhpZGRlbic6IHRydWUsXG4gICAgJ3JvbGUnOiAnaW1nJyxcbn07XG4vKipcbiAqIFN0eWxlIG1vZGVzXG4gKi9cbmNvbnN0IGNvbW1vblByb3BzID0ge1xuICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snLFxufTtcbmNvbnN0IG1vbm90b25lUHJvcHMgPSB7XG4gICAgYmFja2dyb3VuZENvbG9yOiAnY3VycmVudENvbG9yJyxcbn07XG5jb25zdCBjb2xvcmVkUHJvcHMgPSB7XG4gICAgYmFja2dyb3VuZENvbG9yOiAndHJhbnNwYXJlbnQnLFxufTtcbi8vIER5bmFtaWNhbGx5IGFkZCBjb21tb24gcHJvcHMgdG8gdmFyaWFibGVzIGFib3ZlXG5jb25zdCBwcm9wc1RvQWRkID0ge1xuICAgIEltYWdlOiAndmFyKC0tc3ZnKScsXG4gICAgUmVwZWF0OiAnbm8tcmVwZWF0JyxcbiAgICBTaXplOiAnMTAwJSAxMDAlJyxcbn07XG5jb25zdCBwcm9wc1RvQWRkVG8gPSB7XG4gICAgV2Via2l0TWFzazogbW9ub3RvbmVQcm9wcyxcbiAgICBtYXNrOiBtb25vdG9uZVByb3BzLFxuICAgIGJhY2tncm91bmQ6IGNvbG9yZWRQcm9wcyxcbn07XG5mb3IgKGNvbnN0IHByZWZpeCBpbiBwcm9wc1RvQWRkVG8pIHtcbiAgICBjb25zdCBsaXN0ID0gcHJvcHNUb0FkZFRvW3ByZWZpeF07XG4gICAgZm9yIChjb25zdCBwcm9wIGluIHByb3BzVG9BZGQpIHtcbiAgICAgICAgbGlzdFtwcmVmaXggKyBwcm9wXSA9IHByb3BzVG9BZGRbcHJvcF07XG4gICAgfVxufVxuLyoqXG4gKiBEZWZhdWx0IHZhbHVlcyBmb3IgY3VzdG9taXNhdGlvbnMgZm9yIGlubGluZSBpY29uXG4gKi9cbmNvbnN0IGlubGluZURlZmF1bHRzID0ge1xuICAgIC4uLmRlZmF1bHRFeHRlbmRlZEljb25DdXN0b21pc2F0aW9ucyxcbiAgICBpbmxpbmU6IHRydWUsXG59O1xuLyoqXG4gKiBGaXggc2l6ZTogYWRkICdweCcgdG8gbnVtYmVyc1xuICovXG5mdW5jdGlvbiBmaXhTaXplKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICsgKHZhbHVlLm1hdGNoKC9eWy0wLTkuXSskLykgPyAncHgnIDogJycpO1xufVxuLyoqXG4gKiBSZW5kZXIgaWNvblxuICovXG5jb25zdCByZW5kZXIgPSAoXG4vLyBJY29uIG11c3QgYmUgdmFsaWRhdGVkIGJlZm9yZSBjYWxsaW5nIHRoaXMgZnVuY3Rpb25cbmljb24sIFxuLy8gUGFydGlhbCBwcm9wZXJ0aWVzXG5wcm9wcywgXG4vLyBJY29uIG5hbWVcbm5hbWUpID0+IHtcbiAgICAvLyBHZXQgZGVmYXVsdCBwcm9wZXJ0aWVzXG4gICAgY29uc3QgZGVmYXVsdFByb3BzID0gcHJvcHMuaW5saW5lXG4gICAgICAgID8gaW5saW5lRGVmYXVsdHNcbiAgICAgICAgOiBkZWZhdWx0RXh0ZW5kZWRJY29uQ3VzdG9taXNhdGlvbnM7XG4gICAgLy8gR2V0IGFsbCBjdXN0b21pc2F0aW9uc1xuICAgIGNvbnN0IGN1c3RvbWlzYXRpb25zID0gbWVyZ2VDdXN0b21pc2F0aW9ucyhkZWZhdWx0UHJvcHMsIHByb3BzKTtcbiAgICAvLyBDaGVjayBtb2RlXG4gICAgY29uc3QgbW9kZSA9IHByb3BzLm1vZGUgfHwgJ3N2Zyc7XG4gICAgLy8gQ3JlYXRlIHN0eWxlXG4gICAgY29uc3Qgc3R5bGUgPSB7fTtcbiAgICBjb25zdCBjdXN0b21TdHlsZSA9IHByb3BzLnN0eWxlIHx8IHt9O1xuICAgIC8vIENyZWF0ZSBTVkcgY29tcG9uZW50IHByb3BlcnRpZXNcbiAgICBjb25zdCBjb21wb25lbnRQcm9wcyA9IHtcbiAgICAgICAgLi4uKG1vZGUgPT09ICdzdmcnID8gc3ZnRGVmYXVsdHMgOiB7fSksXG4gICAgfTtcbiAgICBpZiAobmFtZSkge1xuICAgICAgICBjb25zdCBpY29uTmFtZSA9IHN0cmluZ1RvSWNvbihuYW1lLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgIGlmIChpY29uTmFtZSkge1xuICAgICAgICAgICAgY29uc3QgY2xhc3NOYW1lcyA9IFsnaWNvbmlmeSddO1xuICAgICAgICAgICAgY29uc3QgcHJvcHMgPSBbXG4gICAgICAgICAgICAgICAgJ3Byb3ZpZGVyJyxcbiAgICAgICAgICAgICAgICAncHJlZml4JyxcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHByb3Agb2YgcHJvcHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoaWNvbk5hbWVbcHJvcF0pIHtcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdpY29uaWZ5LS0nICsgaWNvbk5hbWVbcHJvcF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbXBvbmVudFByb3BzLmNsYXNzTmFtZSA9IGNsYXNzTmFtZXMuam9pbignICcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEdldCBlbGVtZW50IHByb3BlcnRpZXNcbiAgICBmb3IgKGxldCBrZXkgaW4gcHJvcHMpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBwcm9wc1trZXldO1xuICAgICAgICBpZiAodmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChrZXkpIHtcbiAgICAgICAgICAgIC8vIFByb3BlcnRpZXMgdG8gaWdub3JlXG4gICAgICAgICAgICBjYXNlICdpY29uJzpcbiAgICAgICAgICAgIGNhc2UgJ3N0eWxlJzpcbiAgICAgICAgICAgIGNhc2UgJ2NoaWxkcmVuJzpcbiAgICAgICAgICAgIGNhc2UgJ29uTG9hZCc6XG4gICAgICAgICAgICBjYXNlICdtb2RlJzpcbiAgICAgICAgICAgIGNhc2UgJ3Nzcic6XG4gICAgICAgICAgICBjYXNlICdmYWxsYmFjayc6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAvLyBGb3J3YXJkIHJlZlxuICAgICAgICAgICAgY2FzZSAnX3JlZic6XG4gICAgICAgICAgICAgICAgY29tcG9uZW50UHJvcHMucmVmID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAvLyBNZXJnZSBjbGFzcyBuYW1lc1xuICAgICAgICAgICAgY2FzZSAnY2xhc3NOYW1lJzpcbiAgICAgICAgICAgICAgICBjb21wb25lbnRQcm9wc1trZXldID1cbiAgICAgICAgICAgICAgICAgICAgKGNvbXBvbmVudFByb3BzW2tleV0gPyBjb21wb25lbnRQcm9wc1trZXldICsgJyAnIDogJycpICtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgLy8gQm9vbGVhbiBhdHRyaWJ1dGVzXG4gICAgICAgICAgICBjYXNlICdpbmxpbmUnOlxuICAgICAgICAgICAgY2FzZSAnaEZsaXAnOlxuICAgICAgICAgICAgY2FzZSAndkZsaXAnOlxuICAgICAgICAgICAgICAgIGN1c3RvbWlzYXRpb25zW2tleV0gPVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9PT0gdHJ1ZSB8fCB2YWx1ZSA9PT0gJ3RydWUnIHx8IHZhbHVlID09PSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgLy8gRmxpcCBhcyBzdHJpbmc6ICdob3Jpem9udGFsLHZlcnRpY2FsJ1xuICAgICAgICAgICAgY2FzZSAnZmxpcCc6XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgZmxpcEZyb21TdHJpbmcoY3VzdG9taXNhdGlvbnMsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAvLyBDb2xvcjogY29weSB0byBzdHlsZVxuICAgICAgICAgICAgY2FzZSAnY29sb3InOlxuICAgICAgICAgICAgICAgIHN0eWxlLmNvbG9yID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAvLyBSb3RhdGlvbiBhcyBzdHJpbmdcbiAgICAgICAgICAgIGNhc2UgJ3JvdGF0ZSc6XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VzdG9taXNhdGlvbnNba2V5XSA9IHJvdGF0ZUZyb21TdHJpbmcodmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1c3RvbWlzYXRpb25zW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAvLyBSZW1vdmUgYXJpYS1oaWRkZW5cbiAgICAgICAgICAgIGNhc2UgJ2FyaWFIaWRkZW4nOlxuICAgICAgICAgICAgY2FzZSAnYXJpYS1oaWRkZW4nOlxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdHJ1ZSAmJiB2YWx1ZSAhPT0gJ3RydWUnKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBjb21wb25lbnRQcm9wc1snYXJpYS1oaWRkZW4nXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAvLyBDb3B5IG1pc3NpbmcgcHJvcGVydHkgaWYgaXQgZG9lcyBub3QgZXhpc3QgaW4gY3VzdG9taXNhdGlvbnNcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgaWYgKGRlZmF1bHRQcm9wc1trZXldID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50UHJvcHNba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBHZW5lcmF0ZSBpY29uXG4gICAgY29uc3QgaXRlbSA9IGljb25Ub1NWRyhpY29uLCBjdXN0b21pc2F0aW9ucyk7XG4gICAgY29uc3QgcmVuZGVyQXR0cmlicyA9IGl0ZW0uYXR0cmlidXRlcztcbiAgICAvLyBJbmxpbmUgZGlzcGxheVxuICAgIGlmIChjdXN0b21pc2F0aW9ucy5pbmxpbmUpIHtcbiAgICAgICAgc3R5bGUudmVydGljYWxBbGlnbiA9ICctMC4xMjVlbSc7XG4gICAgfVxuICAgIGlmIChtb2RlID09PSAnc3ZnJykge1xuICAgICAgICAvLyBBZGQgc3R5bGVcbiAgICAgICAgY29tcG9uZW50UHJvcHMuc3R5bGUgPSB7XG4gICAgICAgICAgICAuLi5zdHlsZSxcbiAgICAgICAgICAgIC4uLmN1c3RvbVN0eWxlLFxuICAgICAgICB9O1xuICAgICAgICAvLyBBZGQgaWNvbiBzdHVmZlxuICAgICAgICBPYmplY3QuYXNzaWduKGNvbXBvbmVudFByb3BzLCByZW5kZXJBdHRyaWJzKTtcbiAgICAgICAgLy8gQ291bnRlciBmb3IgaWRzIGJhc2VkIG9uIFwiaWRcIiBwcm9wZXJ0eSB0byByZW5kZXIgaWNvbnMgY29uc2lzdGVudGx5IG9uIHNlcnZlciBhbmQgY2xpZW50XG4gICAgICAgIGxldCBsb2NhbENvdW50ZXIgPSAwO1xuICAgICAgICBsZXQgaWQgPSBwcm9wcy5pZDtcbiAgICAgICAgaWYgKHR5cGVvZiBpZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIC8vIENvbnZlcnQgJy0nIHRvICdfJyB0byBhdm9pZCBlcnJvcnMgaW4gYW5pbWF0aW9uc1xuICAgICAgICAgICAgaWQgPSBpZC5yZXBsYWNlKC8tL2csICdfJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIGljb24gc3R1ZmZcbiAgICAgICAgY29tcG9uZW50UHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgPSB7XG4gICAgICAgICAgICBfX2h0bWw6IGNsZWFuVXBJbm5lckhUTUwocmVwbGFjZUlEcyhpdGVtLmJvZHksIGlkID8gKCkgPT4gaWQgKyAnSUQnICsgbG9jYWxDb3VudGVyKysgOiAnaWNvbmlmeVJlYWN0JykpLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gY3JlYXRlRWxlbWVudCgnc3ZnJywgY29tcG9uZW50UHJvcHMpO1xuICAgIH1cbiAgICAvLyBSZW5kZXIgPHNwYW4+IHdpdGggc3R5bGVcbiAgICBjb25zdCB7IGJvZHksIHdpZHRoLCBoZWlnaHQgfSA9IGljb247XG4gICAgY29uc3QgdXNlTWFzayA9IG1vZGUgPT09ICdtYXNrJyB8fFxuICAgICAgICAobW9kZSA9PT0gJ2JnJyA/IGZhbHNlIDogYm9keS5pbmRleE9mKCdjdXJyZW50Q29sb3InKSAhPT0gLTEpO1xuICAgIC8vIEdlbmVyYXRlIFNWR1xuICAgIGNvbnN0IGh0bWwgPSBpY29uVG9IVE1MKGJvZHksIHtcbiAgICAgICAgLi4ucmVuZGVyQXR0cmlicyxcbiAgICAgICAgd2lkdGg6IHdpZHRoICsgJycsXG4gICAgICAgIGhlaWdodDogaGVpZ2h0ICsgJycsXG4gICAgfSk7XG4gICAgLy8gR2VuZXJhdGUgc3R5bGVcbiAgICBjb21wb25lbnRQcm9wcy5zdHlsZSA9IHtcbiAgICAgICAgLi4uc3R5bGUsXG4gICAgICAgICctLXN2Zyc6IHN2Z1RvVVJMKGh0bWwpLFxuICAgICAgICAnd2lkdGgnOiBmaXhTaXplKHJlbmRlckF0dHJpYnMud2lkdGgpLFxuICAgICAgICAnaGVpZ2h0JzogZml4U2l6ZShyZW5kZXJBdHRyaWJzLmhlaWdodCksXG4gICAgICAgIC4uLmNvbW1vblByb3BzLFxuICAgICAgICAuLi4odXNlTWFzayA/IG1vbm90b25lUHJvcHMgOiBjb2xvcmVkUHJvcHMpLFxuICAgICAgICAuLi5jdXN0b21TdHlsZSxcbiAgICB9O1xuICAgIHJldHVybiBjcmVhdGVFbGVtZW50KCdzcGFuJywgY29tcG9uZW50UHJvcHMpO1xufTtcblxuLyoqXG4gKiBJbml0aWFsaXNlIHN0dWZmXG4gKi9cbi8vIEVuYWJsZSBzaG9ydCBuYW1lc1xuYWxsb3dTaW1wbGVOYW1lcyh0cnVlKTtcbi8vIFNldCBBUEkgbW9kdWxlXG5zZXRBUElNb2R1bGUoJycsIGZldGNoQVBJTW9kdWxlKTtcbi8qKlxuICogQnJvd3NlciBzdHVmZlxuICovXG5pZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgIGNvbnN0IF93aW5kb3cgPSB3aW5kb3c7XG4gICAgLy8gTG9hZCBpY29ucyBmcm9tIGdsb2JhbCBcIkljb25pZnlQcmVsb2FkXCJcbiAgICBpZiAoX3dpbmRvdy5JY29uaWZ5UHJlbG9hZCAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGNvbnN0IHByZWxvYWQgPSBfd2luZG93Lkljb25pZnlQcmVsb2FkO1xuICAgICAgICBjb25zdCBlcnIgPSAnSW52YWxpZCBJY29uaWZ5UHJlbG9hZCBzeW50YXguJztcbiAgICAgICAgaWYgKHR5cGVvZiBwcmVsb2FkID09PSAnb2JqZWN0JyAmJiBwcmVsb2FkICE9PSBudWxsKSB7XG4gICAgICAgICAgICAocHJlbG9hZCBpbnN0YW5jZW9mIEFycmF5ID8gcHJlbG9hZCA6IFtwcmVsb2FkXSkuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgaXRlbSBpcyBhbiBvYmplY3QgYW5kIG5vdCBudWxsL2FycmF5XG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiBpdGVtICE9PSAnb2JqZWN0JyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbSA9PT0gbnVsbCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbSBpbnN0YW5jZW9mIEFycmF5IHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBmb3IgJ2ljb25zJyBhbmQgJ3ByZWZpeCdcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiBpdGVtLmljb25zICE9PSAnb2JqZWN0JyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIGl0ZW0ucHJlZml4ICE9PSAnc3RyaW5nJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWRkIGljb24gc2V0XG4gICAgICAgICAgICAgICAgICAgICAgICAhYWRkQ29sbGVjdGlvbihpdGVtKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBTZXQgQVBJIGZyb20gZ2xvYmFsIFwiSWNvbmlmeVByb3ZpZGVyc1wiXG4gICAgaWYgKF93aW5kb3cuSWNvbmlmeVByb3ZpZGVycyAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGNvbnN0IHByb3ZpZGVycyA9IF93aW5kb3cuSWNvbmlmeVByb3ZpZGVycztcbiAgICAgICAgaWYgKHR5cGVvZiBwcm92aWRlcnMgPT09ICdvYmplY3QnICYmIHByb3ZpZGVycyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZm9yIChsZXQga2V5IGluIHByb3ZpZGVycykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVyciA9ICdJY29uaWZ5UHJvdmlkZXJzWycgKyBrZXkgKyAnXSBpcyBpbnZhbGlkLic7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBwcm92aWRlcnNba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICF2YWx1ZSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUucmVzb3VyY2VzID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghYWRkQVBJUHJvdmlkZXIoa2V5LCB2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gSWNvbkNvbXBvbmVudChwcm9wcykge1xuICAgIGNvbnN0IFttb3VudGVkLCBzZXRNb3VudGVkXSA9IHVzZVN0YXRlKCEhcHJvcHMuc3NyKTtcbiAgICBjb25zdCBbYWJvcnQsIHNldEFib3J0XSA9IHVzZVN0YXRlKHt9KTtcbiAgICAvLyBHZXQgaW5pdGlhbCBzdGF0ZVxuICAgIGZ1bmN0aW9uIGdldEluaXRpYWxTdGF0ZShtb3VudGVkKSB7XG4gICAgICAgIGlmIChtb3VudGVkKSB7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gcHJvcHMuaWNvbjtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAvLyBJY29uIGFzIG9iamVjdFxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICcnLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBuYW1lLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gZ2V0SWNvbkRhdGEobmFtZSk7XG4gICAgICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmFtZTogJycsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IFtzdGF0ZSwgc2V0U3RhdGVdID0gdXNlU3RhdGUoZ2V0SW5pdGlhbFN0YXRlKCEhcHJvcHMuc3NyKSk7XG4gICAgLy8gQ2FuY2VsIGxvYWRpbmdcbiAgICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgICAgICBjb25zdCBjYWxsYmFjayA9IGFib3J0LmNhbGxiYWNrO1xuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICBzZXRBYm9ydCh7fSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQ2hhbmdlIHN0YXRlIGlmIGl0IGlzIGRpZmZlcmVudFxuICAgIGZ1bmN0aW9uIGNoYW5nZVN0YXRlKG5ld1N0YXRlKSB7XG4gICAgICAgIGlmIChKU09OLnN0cmluZ2lmeShzdGF0ZSkgIT09IEpTT04uc3RyaW5naWZ5KG5ld1N0YXRlKSkge1xuICAgICAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICAgICAgc2V0U3RhdGUobmV3U3RhdGUpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gVXBkYXRlIHN0YXRlXG4gICAgZnVuY3Rpb24gdXBkYXRlU3RhdGUoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgbmFtZSA9IHByb3BzLmljb247XG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIC8vIEljb24gYXMgb2JqZWN0XG4gICAgICAgICAgICBjaGFuZ2VTdGF0ZSh7XG4gICAgICAgICAgICAgICAgbmFtZTogJycsXG4gICAgICAgICAgICAgICAgZGF0YTogbmFtZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5ldyBpY29uIG9yIGdvdCBpY29uIGRhdGFcbiAgICAgICAgY29uc3QgZGF0YSA9IGdldEljb25EYXRhKG5hbWUpO1xuICAgICAgICBpZiAoY2hhbmdlU3RhdGUoe1xuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgIH0pKSB7XG4gICAgICAgICAgICBpZiAoZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgLy8gTG9hZCBpY29uLCB1cGRhdGUgc3RhdGUgd2hlbiBkb25lXG4gICAgICAgICAgICAgICAgY29uc3QgY2FsbGJhY2sgPSBsb2FkSWNvbnMoW25hbWVdLCB1cGRhdGVTdGF0ZSk7XG4gICAgICAgICAgICAgICAgc2V0QWJvcnQoe1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAvLyBJY29uIGRhdGEgaXMgYXZhaWxhYmxlOiB0cmlnZ2VyIG9uTG9hZCBjYWxsYmFjayBpZiBwcmVzZW50XG4gICAgICAgICAgICAgICAgKF9hID0gcHJvcHMub25Mb2FkKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChwcm9wcywgbmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gTW91bnRlZCBzdGF0ZSwgY2xlYW51cCBmb3IgbG9hZGVyXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgc2V0TW91bnRlZCh0cnVlKTtcbiAgICAgICAgcmV0dXJuIGNsZWFudXA7XG4gICAgfSwgW10pO1xuICAgIC8vIEljb24gY2hhbmdlZCBvciBjb21wb25lbnQgbW91bnRlZFxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChtb3VudGVkKSB7XG4gICAgICAgICAgICB1cGRhdGVTdGF0ZSgpO1xuICAgICAgICB9XG4gICAgfSwgW3Byb3BzLmljb24sIG1vdW50ZWRdKTtcbiAgICAvLyBSZW5kZXIgaWNvblxuICAgIGNvbnN0IHsgbmFtZSwgZGF0YSB9ID0gc3RhdGU7XG4gICAgaWYgKCFkYXRhKSB7XG4gICAgICAgIHJldHVybiBwcm9wcy5jaGlsZHJlblxuICAgICAgICAgICAgPyBwcm9wcy5jaGlsZHJlblxuICAgICAgICAgICAgOiBwcm9wcy5mYWxsYmFja1xuICAgICAgICAgICAgICAgID8gcHJvcHMuZmFsbGJhY2tcbiAgICAgICAgICAgICAgICA6IGNyZWF0ZUVsZW1lbnQoJ3NwYW4nLCB7fSk7XG4gICAgfVxuICAgIHJldHVybiByZW5kZXIoe1xuICAgICAgICAuLi5kZWZhdWx0SWNvblByb3BzLFxuICAgICAgICAuLi5kYXRhLFxuICAgIH0sIHByb3BzLCBuYW1lKTtcbn1cbi8qKlxuICogQmxvY2sgaWNvblxuICpcbiAqIEBwYXJhbSBwcm9wcyAtIENvbXBvbmVudCBwcm9wZXJ0aWVzXG4gKi9cbmNvbnN0IEljb24gPSBmb3J3YXJkUmVmKChwcm9wcywgcmVmKSA9PiBJY29uQ29tcG9uZW50KHtcbiAgICAuLi5wcm9wcyxcbiAgICBfcmVmOiByZWYsXG59KSk7XG4vKipcbiAqIElubGluZSBpY29uIChoYXMgbmVnYXRpdmUgdmVydGljYWxBbGlnbiB0aGF0IG1ha2VzIGl0IGJlaGF2ZSBsaWtlIGljb24gZm9udClcbiAqXG4gKiBAcGFyYW0gcHJvcHMgLSBDb21wb25lbnQgcHJvcGVydGllc1xuICovXG5jb25zdCBJbmxpbmVJY29uID0gZm9yd2FyZFJlZigocHJvcHMsIHJlZikgPT4gSWNvbkNvbXBvbmVudCh7XG4gICAgaW5saW5lOiB0cnVlLFxuICAgIC4uLnByb3BzLFxuICAgIF9yZWY6IHJlZixcbn0pKTtcbi8qKlxuICogSW50ZXJuYWwgQVBJXG4gKi9cbmNvbnN0IF9hcGkgPSB7XG4gICAgZ2V0QVBJQ29uZmlnLFxuICAgIHNldEFQSU1vZHVsZSxcbiAgICBzZW5kQVBJUXVlcnksXG4gICAgc2V0RmV0Y2gsXG4gICAgZ2V0RmV0Y2gsXG4gICAgbGlzdEFQSVByb3ZpZGVycyxcbn07XG5cbmV4cG9ydCB7IEljb24sIElubGluZUljb24sIF9hcGksIGFkZEFQSVByb3ZpZGVyLCBhZGRDb2xsZWN0aW9uLCBhZGRJY29uLCBpY29uVG9TVkcgYXMgYnVpbGRJY29uLCBjYWxjdWxhdGVTaXplLCBnZXRJY29uLCBpY29uTG9hZGVkLCBsaXN0SWNvbnMsIGxvYWRJY29uLCBsb2FkSWNvbnMsIHJlcGxhY2VJRHMsIHNldEN1c3RvbUljb25Mb2FkZXIsIHNldEN1c3RvbUljb25zTG9hZGVyIH07XG4iXSwibmFtZXMiOlsiY3JlYXRlRWxlbWVudCIsImZvcndhcmRSZWYiLCJ1c2VTdGF0ZSIsInVzZUVmZmVjdCIsImdldEljb25zVHJlZSIsImRhdGEiLCJuYW1lcyIsImljb25zIiwiYWxpYXNlcyIsIk9iamVjdCIsImNyZWF0ZSIsInJlc29sdmVkIiwicmVzb2x2ZSIsIm5hbWUiLCJwYXJlbnQiLCJ2YWx1ZSIsImNvbmNhdCIsImtleXMiLCJmb3JFYWNoIiwiZGVmYXVsdEljb25EaW1lbnNpb25zIiwiZnJlZXplIiwibGVmdCIsInRvcCIsIndpZHRoIiwiaGVpZ2h0IiwiZGVmYXVsdEljb25UcmFuc2Zvcm1hdGlvbnMiLCJyb3RhdGUiLCJ2RmxpcCIsImhGbGlwIiwiZGVmYXVsdEljb25Qcm9wcyIsImRlZmF1bHRFeHRlbmRlZEljb25Qcm9wcyIsImJvZHkiLCJoaWRkZW4iLCJtZXJnZUljb25UcmFuc2Zvcm1hdGlvbnMiLCJvYmoxIiwib2JqMiIsInJlc3VsdCIsIm1lcmdlSWNvbkRhdGEiLCJjaGlsZCIsImtleSIsImludGVybmFsR2V0SWNvbkRhdGEiLCJ0cmVlIiwiY3VycmVudFByb3BzIiwicGFyc2UiLCJuYW1lJDEiLCJwYXJzZUljb25TZXQiLCJjYWxsYmFjayIsIm5vdF9mb3VuZCIsIkFycmF5IiwicHVzaCIsIml0ZW0iLCJvcHRpb25hbFByb3BlcnR5RGVmYXVsdHMiLCJwcm92aWRlciIsImNoZWNrT3B0aW9uYWxQcm9wcyIsImRlZmF1bHRzIiwicHJvcCIsInF1aWNrbHlWYWxpZGF0ZUljb25TZXQiLCJvYmoiLCJwcmVmaXgiLCJpY29uIiwiZGF0YVN0b3JhZ2UiLCJuZXdTdG9yYWdlIiwibWlzc2luZyIsIlNldCIsImdldFN0b3JhZ2UiLCJwcm92aWRlclN0b3JhZ2UiLCJhZGRJY29uU2V0Iiwic3RvcmFnZSIsImFkZCIsImFkZEljb25Ub1N0b3JhZ2UiLCJlcnIiLCJsaXN0SWNvbnMiLCJhbGxJY29ucyIsInByb3ZpZGVycyIsInByb3ZpZGVyJDEiLCJwcmVmaXhlcyIsInByZWZpeCQxIiwibWFwIiwibWF0Y2hJY29uTmFtZSIsInN0cmluZ1RvSWNvbiIsInZhbGlkYXRlIiwiYWxsb3dTaW1wbGVOYW1lIiwiY29sb25TZXBhcmF0ZWQiLCJzcGxpdCIsInNsaWNlIiwibGVuZ3RoIiwic2hpZnQiLCJwb3AiLCJ2YWxpZGF0ZUljb25OYW1lIiwiZGFzaFNlcGFyYXRlZCIsImpvaW4iLCJzaW1wbGVOYW1lcyIsImFsbG93U2ltcGxlTmFtZXMiLCJhbGxvdyIsImdldEljb25EYXRhIiwiaWNvbk5hbWUiLCJoYXMiLCJhZGRJY29uIiwiYWRkQ29sbGVjdGlvbiIsImFkZGVkIiwiaWNvbkxvYWRlZCIsImdldEljb24iLCJkZWZhdWx0SWNvblNpemVDdXN0b21pc2F0aW9ucyIsImRlZmF1bHRJY29uQ3VzdG9taXNhdGlvbnMiLCJ1bml0c1NwbGl0IiwidW5pdHNUZXN0IiwiY2FsY3VsYXRlU2l6ZSIsInNpemUiLCJyYXRpbyIsInByZWNpc2lvbiIsIk1hdGgiLCJjZWlsIiwib2xkUGFydHMiLCJuZXdQYXJ0cyIsImNvZGUiLCJpc051bWJlciIsInRlc3QiLCJudW0iLCJwYXJzZUZsb2F0IiwiaXNOYU4iLCJzcGxpdFNWR0RlZnMiLCJjb250ZW50IiwidGFnIiwiZGVmcyIsImluZGV4IiwiaW5kZXhPZiIsInN0YXJ0IiwiZW5kIiwiZW5kRW5kIiwidHJpbSIsIm1lcmdlRGVmc0FuZENvbnRlbnQiLCJ3cmFwU1ZHQ29udGVudCIsImlzVW5zZXRLZXl3b3JkIiwiaWNvblRvU1ZHIiwiY3VzdG9taXNhdGlvbnMiLCJmdWxsSWNvbiIsImZ1bGxDdXN0b21pc2F0aW9ucyIsImJveCIsInByb3BzIiwidHJhbnNmb3JtYXRpb25zIiwicm90YXRpb24iLCJ0b1N0cmluZyIsInRlbXBWYWx1ZSIsImZsb29yIiwidW5zaGlmdCIsImN1c3RvbWlzYXRpb25zV2lkdGgiLCJjdXN0b21pc2F0aW9uc0hlaWdodCIsImJveFdpZHRoIiwiYm94SGVpZ2h0IiwiYXR0cmlidXRlcyIsInNldEF0dHIiLCJ2aWV3Qm94IiwicmVnZXgiLCJyYW5kb21QcmVmaXgiLCJEYXRlIiwibm93IiwicmFuZG9tIiwiY291bnRlciIsInJlcGxhY2VJRHMiLCJpZHMiLCJtYXRjaCIsImV4ZWMiLCJzdWZmaXgiLCJpZCIsIm5ld0lEIiwiZXNjYXBlZElEIiwicmVwbGFjZSIsIlJlZ0V4cCIsInNldEFQSU1vZHVsZSIsImdldEFQSU1vZHVsZSIsImNyZWF0ZUFQSUNvbmZpZyIsInNvdXJjZSIsInJlc291cmNlcyIsInBhdGgiLCJtYXhVUkwiLCJ0aW1lb3V0IiwiZGF0YUFmdGVyVGltZW91dCIsImNvbmZpZ1N0b3JhZ2UiLCJmYWxsQmFja0FQSVNvdXJjZXMiLCJmYWxsQmFja0FQSSIsImFkZEFQSVByb3ZpZGVyIiwiY3VzdG9tQ29uZmlnIiwiY29uZmlnIiwiZ2V0QVBJQ29uZmlnIiwibGlzdEFQSVByb3ZpZGVycyIsImRldGVjdEZldGNoIiwiZmV0Y2giLCJmZXRjaE1vZHVsZSIsInNldEZldGNoIiwiZmV0Y2gkMSIsImdldEZldGNoIiwiY2FsY3VsYXRlTWF4TGVuZ3RoIiwibWF4SG9zdExlbmd0aCIsImhvc3QiLCJtYXgiLCJ1cmwiLCJzaG91bGRBYm9ydCIsInN0YXR1cyIsInByZXBhcmUiLCJyZXN1bHRzIiwibWF4TGVuZ3RoIiwidHlwZSIsImdldFBhdGgiLCJzZW5kIiwicGFyYW1zIiwiaWNvbnNMaXN0IiwidXJsUGFyYW1zIiwiVVJMU2VhcmNoUGFyYW1zIiwidXJpIiwiZGVmYXVsdEVycm9yIiwidGhlbiIsInJlc3BvbnNlIiwic2V0VGltZW91dCIsImpzb24iLCJjYXRjaCIsImZldGNoQVBJTW9kdWxlIiwicmVtb3ZlQ2FsbGJhY2siLCJzdG9yYWdlcyIsIml0ZW1zIiwibG9hZGVyQ2FsbGJhY2tzIiwiZmlsdGVyIiwicm93IiwidXBkYXRlQ2FsbGJhY2tzIiwicGVuZGluZ0NhbGxiYWNrc0ZsYWciLCJoYXNQZW5kaW5nIiwib2xkTGVuZ3RoIiwicGVuZGluZyIsImxvYWRlZCIsImFib3J0IiwiaWRDb3VudGVyIiwic3RvcmVDYWxsYmFjayIsInBlbmRpbmdTb3VyY2VzIiwiYmluZCIsInNvcnRJY29ucyIsInNvcnQiLCJhIiwiYiIsImxvY2FsZUNvbXBhcmUiLCJsYXN0SWNvbiIsImxvY2FsU3RvcmFnZSIsImxpc3QiLCJsaXN0VG9JY29ucyIsImRlZmF1bHRDb25maWciLCJzZW5kUXVlcnkiLCJwYXlsb2FkIiwicXVlcnkiLCJkb25lIiwicmVzb3VyY2VzQ291bnQiLCJzdGFydEluZGV4IiwibmV4dEluZGV4Iiwic3RhcnRUaW1lIiwicXVlcmllc1NlbnQiLCJsYXN0RXJyb3IiLCJ0aW1lciIsInF1ZXVlIiwiZG9uZUNhbGxiYWNrcyIsInJlc2V0VGltZXIiLCJjbGVhclRpbWVvdXQiLCJzdWJzY3JpYmUiLCJvdmVyd3JpdGUiLCJnZXRRdWVyeVN0YXR1cyIsInF1ZXJpZXNQZW5kaW5nIiwiZmFpbFF1ZXJ5IiwiY2xlYXJRdWV1ZSIsIm1vZHVsZVJlc3BvbnNlIiwiaXNFcnJvciIsInF1ZXVlZCIsImV4ZWNOZXh0IiwicmVzb3VyY2UiLCJzdGF0dXMkMSIsImluaXRSZWR1bmRhbmN5IiwiY2ZnIiwicXVlcmllcyIsImNsZWFudXAiLCJxdWVyeUNhbGxiYWNrIiwiZG9uZUNhbGxiYWNrIiwicXVlcnkkMSIsImVycm9yIiwiZmluZCIsImluc3RhbmNlIiwic2V0SW5kZXgiLCJnZXRJbmRleCIsImVtcHR5Q2FsbGJhY2skMSIsInJlZHVuZGFuY3lDYWNoZSIsImdldFJlZHVuZGFuY3lDYWNoZSIsInJlZHVuZGFuY3kiLCJjYWNoZWRSZXVuZGFuY3kiLCJzZW5kQVBJUXVlcnkiLCJ0YXJnZXQiLCJhcGkiLCJjYWNoZWQiLCJtb2R1bGVLZXkiLCJlbXB0eUNhbGxiYWNrIiwibG9hZGVkTmV3SWNvbnMiLCJpY29uc0xvYWRlckZsYWciLCJjaGVja0ljb25OYW1lc0ZvckFQSSIsInZhbGlkIiwiaW52YWxpZCIsInBhcnNlTG9hZGVyUmVzcG9uc2UiLCJjaGVja01pc3NpbmciLCJwZW5kaW5nSWNvbnMiLCJkZWxldGUiLCJwYXJzZWQiLCJjb25zb2xlIiwicGFyc2VQb3NzaWJseUFzeW5jUmVzcG9uc2UiLCJQcm9taXNlIiwibG9hZE5ld0ljb25zIiwiaWNvbnNUb0xvYWQiLCJpY29uc1F1ZXVlRmxhZyIsImljb25zJDEiLCJjdXN0b21JY29uTG9hZGVyIiwibG9hZEljb24iLCJsb2FkSWNvbnMiLCJpY29uU2V0IiwiY2xlYW5lZEljb25zIiwic29ydGVkSWNvbnMiLCJjYWxsQ2FsbGJhY2siLCJuZXdJY29ucyIsInNvdXJjZXMiLCJsYXN0UHJvdmlkZXIiLCJsYXN0UHJlZml4IiwicHJvdmlkZXJOZXdJY29ucyIsInBlbmRpbmdRdWV1ZSIsImZ1bGZpbGwiLCJyZWplY3QiLCJpY29uT2JqIiwic2V0Q3VzdG9tSWNvbnNMb2FkZXIiLCJsb2FkZXIiLCJzZXRDdXN0b21JY29uTG9hZGVyIiwibWVyZ2VDdXN0b21pc2F0aW9ucyIsInZhbHVlVHlwZSIsInNlcGFyYXRvciIsImZsaXBGcm9tU3RyaW5nIiwiY3VzdG9tIiwiZmxpcCIsInN0ciIsInJvdGF0ZUZyb21TdHJpbmciLCJkZWZhdWx0VmFsdWUiLCJ1bml0cyIsInZhbHVlJDEiLCJwYXJzZUludCIsImljb25Ub0hUTUwiLCJyZW5kZXJBdHRyaWJzSFRNTCIsImF0dHIiLCJlbmNvZGVTVkdmb3JVUkwiLCJzdmciLCJzdmdUb0RhdGEiLCJzdmdUb1VSTCIsInBvbGljeSIsImNyZWF0ZVBvbGljeSIsIndpbmRvdyIsInRydXN0ZWRUeXBlcyIsImNyZWF0ZUhUTUwiLCJzIiwiY2xlYW5VcElubmVySFRNTCIsImh0bWwiLCJkZWZhdWx0RXh0ZW5kZWRJY29uQ3VzdG9taXNhdGlvbnMiLCJpbmxpbmUiLCJzdmdEZWZhdWx0cyIsImNvbW1vblByb3BzIiwiZGlzcGxheSIsIm1vbm90b25lUHJvcHMiLCJiYWNrZ3JvdW5kQ29sb3IiLCJjb2xvcmVkUHJvcHMiLCJwcm9wc1RvQWRkIiwiSW1hZ2UiLCJSZXBlYXQiLCJTaXplIiwicHJvcHNUb0FkZFRvIiwiV2Via2l0TWFzayIsIm1hc2siLCJiYWNrZ3JvdW5kIiwiaW5saW5lRGVmYXVsdHMiLCJmaXhTaXplIiwicmVuZGVyIiwiZGVmYXVsdFByb3BzIiwibW9kZSIsInN0eWxlIiwiY3VzdG9tU3R5bGUiLCJjb21wb25lbnRQcm9wcyIsImNsYXNzTmFtZXMiLCJjbGFzc05hbWUiLCJyZWYiLCJjb2xvciIsInJlbmRlckF0dHJpYnMiLCJ2ZXJ0aWNhbEFsaWduIiwiYXNzaWduIiwibG9jYWxDb3VudGVyIiwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwiLCJfX2h0bWwiLCJ1c2VNYXNrIiwiZG9jdW1lbnQiLCJfd2luZG93IiwiSWNvbmlmeVByZWxvYWQiLCJwcmVsb2FkIiwiZSIsIkljb25pZnlQcm92aWRlcnMiLCJJY29uQ29tcG9uZW50IiwibW91bnRlZCIsInNldE1vdW50ZWQiLCJzc3IiLCJzZXRBYm9ydCIsImdldEluaXRpYWxTdGF0ZSIsInN0YXRlIiwic2V0U3RhdGUiLCJjaGFuZ2VTdGF0ZSIsIm5ld1N0YXRlIiwiSlNPTiIsInN0cmluZ2lmeSIsInVwZGF0ZVN0YXRlIiwiX2EiLCJ1bmRlZmluZWQiLCJvbkxvYWQiLCJjYWxsIiwiY2hpbGRyZW4iLCJmYWxsYmFjayIsIkljb24iLCJfcmVmIiwiSW5saW5lSWNvbiIsIl9hcGkiLCJidWlsZEljb24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@iconify/react/dist/iconify.js\n");

/***/ })

};
;